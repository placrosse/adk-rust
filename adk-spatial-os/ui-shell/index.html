<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ADK Spatial OS</title>
    <style>
      :root {
        --bg: #f4f6fb;
        --panel: #ffffff;
        --text: #131927;
        --muted: #5f6d87;
        --line: #dbe2ef;
        --brand: #1554f6;
        --brand-soft: #e8eeff;
        --success: #08785d;
        --warn: #b86307;
        --danger: #b22243;
        --shell-edge: #d0d8ea;
        --dock-width: 104px;
        --side-width: 360px;
        --shell-gap: 14px;
        --shell-pad: 20px;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        background:
          radial-gradient(1200px 460px at 20% -5%, rgba(96, 125, 255, 0.16), transparent 60%),
          radial-gradient(960px 520px at 92% 10%, rgba(28, 201, 152, 0.14), transparent 62%),
          linear-gradient(180deg, #f8fbff 0%, #eef2f8 100%);
        color: var(--text);
        font-family: "IBM Plex Sans", "Segoe UI", system-ui, -apple-system, sans-serif;
      }
      .shell {
        min-height: 100vh;
        display: grid;
        grid-template-rows: auto 1fr;
      }
      .topbar {
        border-bottom: 1px solid var(--line);
        background: rgba(255,255,255,0.88);
        backdrop-filter: blur(10px);
        position: sticky;
        top: 0;
        z-index: 10;
      }
      .topbar-inner {
        width: 100%;
        padding: 14px var(--shell-pad);
        display: grid;
        grid-template-columns: var(--dock-width) minmax(0, 1fr) var(--side-width);
        gap: var(--shell-gap);
        align-items: center;
      }
      .topbar-spacer {
        width: 100%;
        height: 100%;
      }
      .topbar-main {
        display: grid;
        grid-template-columns: 290px minmax(0, 1fr);
        gap: 12px;
        align-items: start;
      }
      .brand h1 {
        margin: 0;
        font-size: 23px;
        letter-spacing: 0.02em;
      }
      .brand p {
        margin: 2px 0 0;
        color: var(--muted);
        font-size: 13px;
      }
      .prompt-stack {
        display: grid;
        gap: 8px;
      }
      .master-prompt {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
        align-items: center;
      }
      .master-prompt input {
        width: 100%;
        padding: 13px 14px;
        border-radius: 12px;
        border: 1px solid var(--line);
        background: #fff;
        color: var(--text);
        font-size: 15px;
      }
      .master-prompt button {
        border: none;
        border-radius: 12px;
        min-height: 44px;
        min-width: 84px;
        padding: 0 18px;
        background: linear-gradient(180deg, #2d6bfa 0%, #1554f6 100%);
        color: #fff;
        font-size: 13px;
        font-weight: 700;
        letter-spacing: 0.02em;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow:
          0 10px 20px rgba(21, 84, 246, 0.28),
          0 1px 0 rgba(255, 255, 255, 0.24) inset;
        transition: transform 150ms ease, box-shadow 150ms ease, filter 150ms ease;
      }
      .master-prompt button:hover {
        transform: translateY(-1px);
        box-shadow:
          0 12px 24px rgba(21, 84, 246, 0.34),
          0 1px 0 rgba(255, 255, 255, 0.3) inset;
      }
      .master-prompt button:active {
        transform: translateY(0);
        box-shadow:
          0 8px 16px rgba(21, 84, 246, 0.24),
          0 1px 0 rgba(255, 255, 255, 0.2) inset;
      }
      .master-prompt button:disabled {
        opacity: 0.78;
        filter: saturate(0.72);
        cursor: wait;
        transform: none;
        box-shadow:
          0 7px 14px rgba(21, 84, 246, 0.18),
          0 1px 0 rgba(255, 255, 255, 0.2) inset;
      }
      .prompt-hints {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .hint-pill {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid #d8e1f4;
        background: rgba(255, 255, 255, 0.9);
        color: #4a5d82;
        font-size: 11px;
        letter-spacing: 0.01em;
      }
      .shortcuts-bar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        justify-content: flex-start;
        margin: 8px var(--shell-pad) 16px;
        padding: 8px 10px;
        border-radius: 12px;
        border: 1px solid rgba(186, 199, 227, 0.82);
        background: rgba(255, 255, 255, 0.82);
        backdrop-filter: blur(8px);
        box-shadow: 0 10px 18px rgba(27, 45, 88, 0.12);
      }
      .shortcuts-prefix {
        color: #5e7092;
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 0.02em;
        white-space: nowrap;
      }
      .shortcuts-bar .hint-pill {
        white-space: nowrap;
      }
      .suggestion-block {
        display: grid;
        gap: 6px;
      }
      .suggestion-line {
        display: flex;
        align-items: center;
        gap: 8px;
        min-height: 28px;
        max-width: 100%;
      }
      .suggestion-label {
        color: #5e7092;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 0.02em;
        white-space: nowrap;
      }
      .prompt-inline {
        border: none;
        background: transparent;
        color: #2e4f8e;
        padding: 0;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        text-align: left;
        line-height: 1.3;
        max-width: 100%;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        text-decoration: underline;
        text-decoration-thickness: 1px;
        text-underline-offset: 2px;
        transition: color 140ms ease, opacity 180ms ease;
      }
      .prompt-inline:hover {
        color: #1554f6;
      }
      .prompt-inline:focus-visible {
        outline: none;
        color: #1554f6;
        text-decoration-thickness: 2px;
      }
      .master-prompt input:focus-visible,
      .master-prompt button:focus-visible,
      .dock-btn:focus-visible,
      .surface:focus-visible,
      .actions button:focus-visible {
        outline: none;
        border-color: rgba(21, 84, 246, 0.75);
        box-shadow:
          0 0 0 3px rgba(21, 84, 246, 0.22),
          0 1px 0 rgba(255, 255, 255, 0.9) inset;
      }
      .status-grid {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 8px;
        justify-self: stretch;
      }
      .stat {
        background: #fff;
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px 10px;
      }
      .stat .k { font-size: 11px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.08em; }
      .stat .v { margin-top: 2px; font-size: 18px; font-weight: 700; }

      .body {
        width: 100%;
        padding: 14px var(--shell-pad) 20px;
        display: grid;
        grid-template-columns: var(--dock-width) minmax(0, 1fr) var(--side-width);
        gap: var(--shell-gap);
        min-height: calc(100vh - 84px);
        align-items: start;
      }
      .dock {
        position: relative;
        background: rgba(255, 255, 255, 0.78);
        border: 1px solid var(--shell-edge);
        border-radius: 16px;
        padding: 10px 8px 14px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: center;
        backdrop-filter: blur(8px);
        perspective: 900px;
        overflow: hidden;
      }
      .dock::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: inherit;
        background:
          radial-gradient(110% 65% at 0% 8%, rgba(42, 113, 255, 0.14), transparent 62%),
          linear-gradient(180deg, rgba(255, 255, 255, 0.58) 0%, rgba(255, 255, 255, 0) 52%);
        pointer-events: none;
      }
      .dock-btn {
        --dock-tilt-x: 0deg;
        --dock-tilt-y: 0deg;
        --dock-depth: 0px;
        width: 74px;
        min-height: 66px;
        border: 1px solid var(--line);
        border-radius: 14px;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.98) 0%, rgba(244, 248, 255, 0.96) 100%);
        cursor: pointer;
        font-size: 11px;
        color: var(--muted);
        padding: 8px 6px 7px;
        display: grid;
        justify-items: center;
        align-content: center;
        gap: 6px;
        position: relative;
        transform-style: preserve-3d;
        transform: translate3d(0, 0, var(--dock-depth)) rotateX(var(--dock-tilt-x)) rotateY(var(--dock-tilt-y));
        box-shadow:
          0 10px 20px rgba(19, 36, 74, 0.12),
          0 1px 0 rgba(255, 255, 255, 0.82) inset;
        transition: transform 170ms ease, border-color 170ms ease, box-shadow 170ms ease, color 170ms ease;
        z-index: 1;
      }
      .dock-btn::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: inherit;
        background: radial-gradient(120% 75% at 50% 0%, rgba(255, 255, 255, 0.65), transparent 65%);
        pointer-events: none;
      }
      .dock-btn:hover {
        --dock-depth: 10px;
        border-color: rgba(21, 84, 246, 0.38);
        color: #3a568f;
        box-shadow:
          0 16px 26px rgba(19, 36, 74, 0.18),
          0 1px 0 rgba(255, 255, 255, 0.9) inset;
      }
      .dock-btn-icon {
        width: 28px;
        height: 28px;
        border-radius: 9px;
        display: grid;
        place-items: center;
        font-size: 12px;
        font-weight: 700;
        color: #49608f;
        background: #ebf1ff;
        border: 1px solid #d8e4ff;
      }
      .dock-btn-label {
        display: block;
        max-width: 62px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        line-height: 1;
      }
      .dock-btn.active {
        border-color: var(--brand);
        background: var(--brand-soft);
        color: var(--brand);
        --dock-depth: 14px;
        box-shadow:
          0 18px 28px rgba(21, 84, 246, 0.2),
          0 0 0 1px rgba(21, 84, 246, 0.22);
      }
      .dock-btn.active .dock-btn-icon {
        color: #ffffff;
        background: #2d6bfa;
        border-color: #2d6bfa;
      }

      .workspace {
        background: rgba(255, 255, 255, 0.78);
        border: 1px solid var(--shell-edge);
        border-radius: 18px;
        padding: 14px;
        display: grid;
        grid-template-rows: auto 1fr;
        gap: 10px;
        min-height: 0;
        backdrop-filter: blur(9px);
      }
      .workspace-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .workspace-header h2 { margin: 0; font-size: 20px; }
      .workspace-header span {
        font-size: 12px;
        color: var(--muted);
      }
      .spatial-stage {
        position: relative;
        border: 1px solid var(--line);
        border-radius: 14px;
        background:
          linear-gradient(160deg, rgba(255, 255, 255, 0.93) 0%, rgba(241, 246, 255, 0.95) 100%);
        overflow: auto;
        perspective: 1450px;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.75);
      }
      .spatial-plane {
        position: relative;
        min-height: 780px;
        min-width: 100%;
        transform-style: preserve-3d;
        transition: transform 180ms ease-out;
        background:
          linear-gradient(rgba(27, 50, 94, 0.04) 1px, transparent 1px),
          linear-gradient(90deg, rgba(27, 50, 94, 0.04) 1px, transparent 1px);
        background-size: 36px 36px;
      }
      .surface {
        position: absolute;
        border: 1px solid rgba(169, 186, 220, 0.9);
        border-radius: 16px;
        padding: 12px;
        background:
          linear-gradient(180deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 251, 255, 0.96) 100%);
        box-shadow:
          0 20px 34px rgba(21, 34, 66, 0.14),
          0 1px 0 rgba(255, 255, 255, 0.84) inset;
        transform-origin: center center;
        transition: transform 220ms ease, box-shadow 220ms ease, border-color 220ms ease;
        cursor: grab;
        user-select: none;
        touch-action: none;
      }
      .surface.dragging {
        cursor: grabbing;
        transition: none;
      }
      .surface:hover {
        transform: translateZ(26px) scale(1.01);
        box-shadow:
          0 28px 42px rgba(21, 34, 66, 0.2),
          0 1px 0 rgba(255, 255, 255, 0.9) inset;
      }
      .surface.active {
        border-color: rgba(21, 84, 246, 0.78);
        box-shadow:
          0 34px 48px rgba(21, 84, 246, 0.22),
          0 0 0 1px rgba(21, 84, 246, 0.23);
      }
      .surface-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }
      .surface-title {
        display: flex;
        align-items: center;
        gap: 8px;
        min-width: 0;
      }
      .surface h3 {
        margin: 0;
        font-size: 16px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .surface-controls {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      .surface-btn {
        border: 1px solid #d2def7;
        background: linear-gradient(180deg, #ffffff 0%, #f2f6ff 100%);
        color: #3d5688;
        border-radius: 8px;
        width: 28px;
        height: 24px;
        padding: 0;
        line-height: 1;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: border-color 140ms ease, transform 140ms ease, box-shadow 140ms ease;
      }
      .surface-btn svg {
        width: 14px;
        height: 14px;
        stroke: currentColor;
        fill: none;
        stroke-width: 1.8;
        stroke-linecap: round;
        stroke-linejoin: round;
        pointer-events: none;
      }
      .surface-btn:hover:not(:disabled) {
        border-color: rgba(21, 84, 246, 0.48);
        transform: translateY(-1px);
        box-shadow: 0 6px 12px rgba(21, 84, 246, 0.14);
      }
      .surface-btn:disabled {
        opacity: 0.45;
        cursor: default;
      }
      .surface.minimized {
        padding-bottom: 10px;
      }
      .surface.minimized p {
        display: none;
      }
      .surface p {
        margin: 6px 0 0;
        color: var(--muted);
        font-size: 13px;
        line-height: 1.45;
      }
      .surface-app {
        font-size: 11px;
        color: #47639e;
        background: #eaf0ff;
        border-radius: 999px;
        padding: 3px 8px;
        max-width: 160px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .surface-empty {
        padding: 26px;
        color: var(--muted);
        text-align: center;
        font-weight: 600;
      }

      .sidebar {
        position: relative;
        display: grid;
        gap: 12px;
        align-content: start;
        min-height: 0;
        perspective: 1200px;
        transform-style: preserve-3d;
      }
      .sidebar::before {
        content: "";
        position: absolute;
        inset: 8px 6px;
        border-radius: 16px;
        pointer-events: none;
        background:
          radial-gradient(90% 45% at 10% 12%, rgba(49, 121, 255, 0.14), transparent 62%),
          radial-gradient(86% 44% at 85% 88%, rgba(20, 188, 151, 0.13), transparent 66%);
        filter: blur(12px);
        z-index: 0;
      }
      .panel {
        --tilt-x: 0deg;
        --tilt-y: 0deg;
        --depth: 0px;
        --offset: 0px;
        --mx: 50%;
        --my: 14%;
        position: relative;
        background: rgba(255, 255, 255, 0.78);
        border: 1px solid var(--shell-edge);
        border-radius: 14px;
        padding: 10px;
        backdrop-filter: blur(9px);
        overflow: hidden;
        box-shadow:
          0 16px 28px rgba(16, 33, 73, 0.12),
          0 1px 0 rgba(255, 255, 255, 0.86) inset;
        transform-style: preserve-3d;
        transform: translate3d(var(--offset), 0, var(--depth)) rotateX(var(--tilt-x)) rotateY(var(--tilt-y));
        transition: border-color 220ms ease, box-shadow 220ms ease, transform 220ms ease;
        will-change: transform;
        z-index: 1;
        animation: panelFloat 8.5s ease-in-out infinite;
      }
      .panel::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: inherit;
        background:
          radial-gradient(140% 80% at var(--mx) var(--my), rgba(255, 255, 255, 0.72), rgba(255, 255, 255, 0) 56%),
          linear-gradient(150deg, rgba(255, 255, 255, 0.52) 0%, rgba(255, 255, 255, 0) 62%);
        pointer-events: none;
      }
      .panel::after {
        content: "";
        position: absolute;
        left: 14px;
        right: 14px;
        bottom: -14px;
        height: 18px;
        border-radius: 999px;
        background: rgba(24, 45, 95, 0.14);
        filter: blur(10px);
        opacity: 0.5;
        pointer-events: none;
        transition: opacity 220ms ease;
      }
      .panel:hover {
        border-color: rgba(21, 84, 246, 0.38);
        box-shadow:
          0 24px 38px rgba(16, 33, 73, 0.18),
          0 1px 0 rgba(255, 255, 255, 0.9) inset;
      }
      .panel:hover::after {
        opacity: 0.68;
      }
      .panel:nth-child(1) { z-index: 4; }
      .panel:nth-child(2) { z-index: 3; }
      .panel:nth-child(3) { z-index: 2; }
      .panel > * {
        position: relative;
        z-index: 2;
        transform: translateZ(14px);
      }
      .panel h3 {
        margin: 0 0 8px;
        font-size: 16px;
        transform: translateZ(20px);
      }
      .timeline {
        max-height: 300px;
        overflow: auto;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .entry {
        border: 1px solid var(--line);
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.9);
        padding: 8px;
      }
      .entry .lvl {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: var(--muted);
      }
      .entry .msg {
        margin-top: 4px;
        font-size: 13px;
      }
      .trust {
        display: grid;
        gap: 8px;
      }
      .policy-status {
        border: 1px solid var(--line);
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.9);
        padding: 8px;
      }
      .policy-label {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: var(--muted);
      }
      .policy-value {
        margin-top: 4px;
        font-size: 13px;
      }
      .policy-value.ok { color: var(--success); }
      .policy-value.warn { color: var(--warn); }
      .policy-value.neutral { color: var(--muted); }
      .risk-badge {
        display: inline-block;
        border-radius: 999px;
        padding: 4px 8px;
        font-size: 11px;
        font-weight: 700;
      }
      .risk-dangerous { background: #ffe8ee; color: var(--danger); }
      .risk-controlled { background: #fff1de; color: var(--warn); }
      .risk-safe { background: #e6faf1; color: var(--success); }
      .actions {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }
      .actions button {
        border: none;
        border-radius: 10px;
        padding: 10px;
        font-weight: 600;
        cursor: pointer;
      }
      .approve { background: #0f9e79; color: #fff; }
      .reject { background: #eb486f; color: #fff; }
      .approve:disabled, .reject:disabled { opacity: 0.5; cursor: not-allowed; }
      .log {
        max-height: 220px;
        overflow: auto;
        white-space: pre-wrap;
        background: rgba(244, 248, 255, 0.84);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        font-size: 12px;
      }
      @keyframes panelFloat {
        0% { transform: translate3d(var(--offset), 0px, var(--depth)) rotateX(var(--tilt-x)) rotateY(var(--tilt-y)); }
        50% { transform: translate3d(var(--offset), -2px, calc(var(--depth) + 2px)) rotateX(var(--tilt-x)) rotateY(var(--tilt-y)); }
        100% { transform: translate3d(var(--offset), 0px, var(--depth)) rotateX(var(--tilt-x)) rotateY(var(--tilt-y)); }
      }
      @media (prefers-reduced-motion: reduce) {
        .panel, .surface, .spatial-plane {
          animation: none !important;
          transition: none !important;
        }
      }
      @media (max-width: 1200px) {
        .topbar-inner {
          grid-template-columns: 1fr;
          gap: 10px;
        }
        .topbar-spacer {
          display: none;
        }
        .topbar-main {
          grid-template-columns: 1fr;
          gap: 10px;
        }
        .shortcuts-bar {
          margin: 8px 12px 12px;
          justify-content: flex-start;
        }
        .body { grid-template-columns: 1fr; }
        .dock {
          flex-direction: row;
          justify-content: start;
          overflow-x: auto;
          padding: 10px;
        }
        .dock-btn {
          min-width: 74px;
        }
        .spatial-plane {
          min-height: 560px;
          padding: 10px;
          background: none;
        }
        .surface {
          position: relative;
          left: auto !important;
          top: auto !important;
          width: auto !important;
          height: auto !important;
          transform: none !important;
          margin-bottom: 10px;
        }
        .panel {
          animation: none !important;
          transform: none !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <header class="topbar">
        <div class="topbar-inner">
          <div class="topbar-spacer" aria-hidden="true"></div>
          <div class="topbar-main">
            <div class="brand">
              <h1>ADK Spatial OS</h1>
              <p>Agent-native desktop operating system</p>
            </div>
            <div class="prompt-stack">
              <div class="master-prompt">
                <input id="prompt" value="Summarize platform health and propose safe mitigation options." />
                <button id="run">Run</button>
              </div>
              <div class="suggestion-block">
                <div class="suggestion-line">
                  <span id="suggestionTitle" class="suggestion-label">Suggested prompt:</span>
                  <button id="promptSuggestionCurrent" class="prompt-inline" type="button"></button>
                </div>
              </div>
            </div>
          </div>
          <div class="status-grid">
            <div class="stat"><div class="k">Server</div><div class="v" id="server">n/a</div></div>
            <div class="stat"><div class="k">Session</div><div class="v" id="session">n/a</div></div>
            <div class="stat"><div class="k">Status</div><div class="v" id="status">idle</div></div>
          </div>
        </div>
      </header>

      <main class="body">
        <aside class="dock" id="dock"></aside>

        <section class="workspace">
          <div class="workspace-header">
            <h2>Spatial Workspace</h2>
            <span id="focused">focused: none</span>
          </div>
          <div class="spatial-stage">
            <div id="surfaces" class="spatial-plane"></div>
          </div>
        </section>

        <aside class="sidebar">
          <section class="panel">
            <h3>Trust Panel</h3>
            <div class="trust">
              <div id="approvalTitle">No pending approval</div>
              <div id="approvalRisk"></div>
              <div class="policy-status">
                <div class="policy-label">Policy Decision</div>
                <div id="policyDecision" class="policy-value neutral">No policy decision yet</div>
              </div>
              <div class="actions">
                <button id="approve" class="approve" disabled>Approve</button>
                <button id="reject" class="reject" disabled>Reject</button>
              </div>
            </div>
          </section>

          <section class="panel">
            <h3>Timeline</h3>
            <div id="timeline" class="timeline"></div>
          </section>

          <section class="panel">
            <h3>Runtime Log</h3>
            <div id="log" class="log"></div>
          </section>
        </aside>
      </main>
    </div>

    <footer class="shortcuts-bar" aria-label="Keyboard shortcuts">
      <span class="shortcuts-prefix">Keyboard shortcuts:</span>
      <span class="hint-pill">⌘/Ctrl + K focus prompt</span>
      <span class="hint-pill">Enter to run prompt</span>
      <span class="hint-pill">⌘/Ctrl + [ ] cycle app</span>
    </footer>

    <script>
      const statusEl = document.getElementById('status');
      const serverEl = document.getElementById('server');
      const sessionEl = document.getElementById('session');
      const promptEl = document.getElementById('prompt');
      const runBtn = document.getElementById('run');
      const suggestionTitleEl = document.getElementById('suggestionTitle');
      const promptSuggestionCurrentEl = document.getElementById('promptSuggestionCurrent');
      const dockEl = document.getElementById('dock');
      const surfacesEl = document.getElementById('surfaces');
      const stageEl = document.querySelector('.spatial-stage');
      const workspaceEl = document.querySelector('.workspace');
      const sidebarEl = document.querySelector('.sidebar');
      const focusedEl = document.getElementById('focused');
      const timelineEl = document.getElementById('timeline');
      const logEl = document.getElementById('log');
      const approvalTitleEl = document.getElementById('approvalTitle');
      const approvalRiskEl = document.getElementById('approvalRisk');
      const policyDecisionEl = document.getElementById('policyDecision');
      const approveBtn = document.getElementById('approve');
      const rejectBtn = document.getElementById('reject');

      let sessionId = null;
      let stream = null;
      let reconnectTimer = null;
      let reconnectAttempts = 0;
      let lastParseErrorAt = 0;
      let lastDisconnectNoticeAt = 0;
      let suggestionCycleTimer = null;
      let suggestionCycleItems = [];
      let suggestionCycleIndex = 0;
      let suggestionSignature = '';
      let pendingApproval = null;
      const appCatalog = new Map();
      const surfaces = new Map();
      const surfaceElements = new Map();
      const surfaceWindowState = new Map();
      const SURFACE_GRID_SIZE = 24;
      const STAGE_EDGE_PADDING = 18;
      const MAXIMIZED_SURFACE_MARGIN = 26;
      const MIN_SURFACE_HEIGHT = 76;
      const MIN_SURFACE_WIDTH = 280;
      const sidebarPanels = Array.from(document.querySelectorAll('.sidebar .panel'));
      const sidebarDepths = sidebarPanels.map((_, index) => Math.max(0, 20 - (index * 6)));
      const sidebarOffsets = sidebarPanels.map((_, index) => {
        if (index === 0) return -6;
        if (index === 1) return 2;
        return 10;
      });
      const sidebarYawBase = sidebarPanels.map((_, index) => {
        if (index === 0) return -0.9;
        if (index === 1) return -0.15;
        return 0.7;
      });
      const DEFAULT_PROMPT_SUGGESTIONS = [
        'Summarize platform health and propose safe mitigation options.',
        'Draft an incident update email for leadership with current risks.',
        'Prepare a 30-minute cross-team mitigation meeting agenda for today.',
      ];
      let currentActiveApps = [];
      let hasRunPrompt = false;

      function setStatus(value) { statusEl.textContent = value; }
      function readServerPort() {
        if (window.location.port) return window.location.port;
        return window.location.protocol === 'https:' ? '443' : '80';
      }
      function readServerEndpoint() {
        return `${window.location.hostname}:${readServerPort()}`;
      }
      function setServerInfo() {
        if (!serverEl) return;
        serverEl.textContent = readServerEndpoint();
      }
      const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
      const shortLabel = (name) => {
        if (!name) return 'App';
        return name.length > 9 ? `${name.slice(0, 8)}...` : name;
      };
      const appGlyph = (name) => {
        if (!name) return 'A';
        return name
          .split(/\s+/)
          .filter(Boolean)
          .slice(0, 2)
          .map((part) => part[0].toUpperCase())
          .join('');
      };
      const readNum = (value, fallback) => {
        const n = typeof value === 'string' ? parseFloat(value) : Number(value);
        return Number.isFinite(n) ? n : fallback;
      };
      const snapToGrid = (value, grid = SURFACE_GRID_SIZE) => Math.round(value / grid) * grid;
      const getStageBoundsForSize = (w, h) => {
        const stageWidth = Math.max(
          stageEl ? stageEl.clientWidth : 0,
          surfacesEl ? surfacesEl.scrollWidth : 0,
          readNum(surfacesEl?.style?.minWidth, 0),
        );
        const stageHeight = Math.max(
          stageEl ? stageEl.clientHeight : 0,
          surfacesEl ? surfacesEl.scrollHeight : 0,
          readNum(surfacesEl?.style?.minHeight, 0),
        );
        const minX = STAGE_EDGE_PADDING;
        const minY = STAGE_EDGE_PADDING;
        const maxX = Math.max(minX, stageWidth - w - STAGE_EDGE_PADDING);
        const maxY = Math.max(minY, stageHeight - h - STAGE_EDGE_PADDING);
        return { minX, minY, maxX, maxY };
      };
      const constrainSurfacePosition = (surface, x, y, snap = false) => {
        const { w, h } = getSurfaceBounds(surface);
        const bounds = getStageBoundsForSize(w, h);
        const nx = snap ? snapToGrid(x) : x;
        const ny = snap ? snapToGrid(y) : y;
        return {
          x: Math.round(clamp(nx, bounds.minX, bounds.maxX)),
          y: Math.round(clamp(ny, bounds.minY, bounds.maxY)),
        };
      };
      const getSurfaceBounds = (surface) => ({
        x: readNum(surface?.props?.x, 48),
        y: readNum(surface?.props?.y, 56),
        w: readNum(surface?.props?.w, 420),
        h: readNum(surface?.props?.h, 280),
        z: readNum(surface?.props?.z_index, 10),
      });
      const getSurfaceWindowMode = (surfaceId) => {
        const state = surfaceWindowState.get(surfaceId);
        return state?.mode || 'normal';
      };
      const inferSurfaceWindowMode = (surface) => {
        const current = getSurfaceBounds(surface);
        if (current.h <= (MIN_SURFACE_HEIGHT + 2)) {
          return 'minimized';
        }
        const full = getMaximizedSurfaceRect();
        const isMaximized =
          Math.abs(current.x - full.x) <= 8
          && Math.abs(current.y - full.y) <= 8
          && Math.abs(current.w - full.w) <= 14
          && Math.abs(current.h - full.h) <= 14;
        return isMaximized ? 'maximized' : 'normal';
      };
      const isRectClose = (left, right, positionTolerance = 6, sizeTolerance = 10) => (
        Math.abs(left.x - right.x) <= positionTolerance
        && Math.abs(left.y - right.y) <= positionTolerance
        && Math.abs(left.w - right.w) <= sizeTolerance
        && Math.abs(left.h - right.h) <= sizeTolerance
      );
      function getOrCreateSurfaceWindowState(surfaceId) {
        let state = surfaceWindowState.get(surfaceId);
        if (!state) {
          state = {
            mode: 'normal',
            restoreRect: null,
            initialized: false,
          };
          surfaceWindowState.set(surfaceId, state);
        }
        return state;
      }
      function syncSurfaceWindowState(surfaceId, surface) {
        const state = getOrCreateSurfaceWindowState(surfaceId);
        const current = getSurfaceBounds(surface);
        const inferredMode = inferSurfaceWindowMode(surface);
        const maximizedRect = getMaximizedSurfaceRect();

        if (!state.initialized) {
          state.mode = inferredMode;
          state.initialized = true;
        } else if (state.mode === 'normal') {
          if (inferredMode === 'minimized' || inferredMode === 'maximized') {
            state.mode = inferredMode;
          }
        } else if (state.mode === 'minimized') {
          if (inferredMode !== 'minimized') {
            if (state.restoreRect && isRectClose(current, state.restoreRect)) {
              state.mode = 'normal';
            } else {
              state.mode = inferredMode;
            }
          }
        } else if (state.mode === 'maximized') {
          if (inferredMode === 'minimized') {
            state.mode = 'minimized';
          } else if (inferredMode === 'normal' && state.restoreRect && isRectClose(current, state.restoreRect)) {
            state.mode = 'normal';
          } else if (inferredMode === 'normal' && !isRectClose(current, maximizedRect, 14, 18)) {
            // External layout/focus updates can move a maximized card back to normal geometry.
            // Treat that as normal so window controls and dragging don't get stuck.
            state.mode = 'normal';
          }
        }
        if (state.mode === 'normal') {
          state.restoreRect = { x: current.x, y: current.y, w: current.w, h: current.h };
        } else if (!state.restoreRect) {
          state.restoreRect = {
            x: current.x,
            y: current.y,
            w: Math.max(current.w, MIN_SURFACE_WIDTH),
            h: Math.max(current.h, 240),
          };
        }
        return state;
      }
      function getMaximizedSurfaceRect() {
        const stageWidth = Math.max(stageEl ? stageEl.clientWidth : 0, 320);
        const stageHeight = Math.max(stageEl ? stageEl.clientHeight : 0, 220);
        const safeMargin = Math.max(STAGE_EDGE_PADDING, MAXIMIZED_SURFACE_MARGIN);
        const availableWidth = Math.max(120, stageWidth - (safeMargin * 2) - 2);
        const availableHeight = Math.max(120, stageHeight - (safeMargin * 2) - 2);
        return {
          x: safeMargin,
          y: safeMargin,
          w: availableWidth,
          h: availableHeight,
        };
      }
      function restoreSurfaceToNormal(surfaceId) {
        const surface = surfaces.get(surfaceId);
        const state = surfaceWindowState.get(surfaceId);
        if (!surface || !state || !state.restoreRect) return false;
        surface.props = {
          ...(surface.props || {}),
          x: state.restoreRect.x,
          y: state.restoreRect.y,
          w: state.restoreRect.w,
          h: state.restoreRect.h,
        };
        state.mode = 'normal';
        return true;
      }
      function normalizeOtherMaximizedSurfaces(activeSurfaceId) {
        let changed = false;
        for (const [surfaceId, state] of surfaceWindowState.entries()) {
          if (surfaceId === activeSurfaceId || state.mode !== 'maximized') continue;
          changed = restoreSurfaceToNormal(surfaceId) || changed;
        }
        return changed;
      }
      function applySurfaceWindowAction(surfaceId, action) {
        const surface = surfaces.get(surfaceId);
        if (!surface) return;
        const state = syncSurfaceWindowState(surfaceId, surface);
        const current = getSurfaceBounds(surface);
        let layoutChanged = false;
        if (action === 'maximize') {
          layoutChanged = normalizeOtherMaximizedSurfaces(surfaceId);
        }

        if (action === 'minimize') {
          if (state.mode === 'normal') {
            state.restoreRect = { x: current.x, y: current.y, w: current.w, h: current.h };
          }
          if (state.mode === 'maximized' && !state.restoreRect) {
            state.restoreRect = { x: current.x, y: current.y, w: current.w, h: current.h };
          }
          const restoreX = state.restoreRect ? state.restoreRect.x : current.x;
          const restoreY = state.restoreRect ? state.restoreRect.y : current.y;
          const baseW = state.restoreRect ? state.restoreRect.w : current.w;
          const snapped = constrainSurfacePosition(
            surface,
            restoreX,
            restoreY,
            true,
          );
          surface.props = {
            ...(surface.props || {}),
            x: snapped.x,
            y: snapped.y,
            w: Math.max(MIN_SURFACE_WIDTH, Math.min(baseW, 460)),
            h: MIN_SURFACE_HEIGHT,
          };
          state.mode = 'minimized';
          layoutChanged = true;
        } else if (action === 'maximize') {
          if (state.mode === 'normal') {
            state.restoreRect = { x: current.x, y: current.y, w: current.w, h: current.h };
          }
          if (state.mode === 'minimized' && !state.restoreRect) {
            state.restoreRect = { x: current.x, y: current.y, w: current.w, h: current.h };
          }
          const maxRect = getMaximizedSurfaceRect();
          surface.props = {
            ...(surface.props || {}),
            ...maxRect,
          };
          state.mode = 'maximized';
          layoutChanged = true;
        } else if (action === 'restore') {
          if (restoreSurfaceToNormal(surfaceId)) {
            layoutChanged = true;
          } else {
            state.mode = 'normal';
          }
        } else {
          return;
        }

        bringSurfaceToFront(surfaceId);
        if (surface.app_id) {
          focusApp(surface.app_id, true);
        }
        renderSurfaces();
        if (layoutChanged) {
          emitWorkspaceLayoutChange();
        }
      }
      const surfaceTransform = (surface, lift = 0) => {
        const { z } = getSurfaceBounds(surface);
        const depth = Math.max(0, z - 8) * 14;
        const skew = ((z % 3) - 1) * 0.4;
        return `translate3d(0, 0, ${depth + lift}px) rotateX(0.45deg) rotateY(${skew}deg)`;
      };
      function applySurfaceStyles(card, surface, lift = 0) {
        const { x, y, w, h, z } = getSurfaceBounds(surface);
        card.style.left = `${x}px`;
        card.style.top = `${y}px`;
        card.style.width = `${w}px`;
        card.style.height = `${h}px`;
        card.style.zIndex = String(z);
        card.style.transform = surfaceTransform(surface, lift);
      }
      function serializeSurfaceLayout() {
        return Array.from(surfaces.values())
          .map((surface) => {
            const { x, y, w, h, z } = getSurfaceBounds(surface);
            return {
              id: surface.id,
              app_id: surface.app_id || '',
              x,
              y,
              w,
              h,
              z_index: z,
            };
          })
          .sort((a, b) => a.id.localeCompare(b.id));
      }
      function log(label, data) {
        const line = `[${new Date().toISOString()}] ${label}${data ? `\n${JSON.stringify(data, null, 2)}` : ''}`;
        logEl.textContent = `${line}\n\n${logEl.textContent}`;
      }
      function trace(event, data = {}) {
        log(`trace.${event}`, {
          endpoint: readServerEndpoint(),
          ...data,
        });
      }
      function pushTimeline(level, message) {
        const item = document.createElement('div');
        item.className = 'entry';
        item.innerHTML = `<div class="lvl">${level}</div><div class="msg">${message}</div>`;
        timelineEl.prepend(item);
      }

      function parseSseEnvelope(raw, eventName) {
        if (raw === undefined || raw === null) return null;
        const text = String(raw).trim();
        if (!text || text === 'undefined' || text === 'null') return null;
        try {
          return JSON.parse(text);
        } catch (error) {
          const now = Date.now();
          if ((now - lastParseErrorAt) > 3000) {
            lastParseErrorAt = now;
            log('sse.parse.error', {
              event: eventName,
              message: String(error),
              sample: text.slice(0, 220),
            });
          }
          return null;
        }
      }

      function scheduleStreamReconnect() {
        if (reconnectTimer) return;
        reconnectAttempts += 1;
        const delayMs = Math.min(1000 * (2 ** Math.max(0, reconnectAttempts - 1)), 10000);
        trace('stream.reconnect.scheduled', {
          session_id: sessionId,
          attempt: reconnectAttempts,
          delay_ms: delayMs,
        });
        const now = Date.now();
        if ((now - lastDisconnectNoticeAt) > 5000) {
          lastDisconnectNoticeAt = now;
          pushTimeline('warn', `Stream disconnected. Reconnecting in ${Math.round(delayMs / 1000)}s.`);
        }
        reconnectTimer = setTimeout(() => {
          reconnectTimer = null;
          connectStream();
        }, delayMs);
      }

      function resolvePromptSuggestions() {
        const promptsForApp = (appId) => {
          const manifest = appCatalog.get(appId);
          if (!manifest || !Array.isArray(manifest.starter_prompts)) {
            return [];
          }
          return manifest.starter_prompts
            .map((prompt) => String(prompt || '').trim())
            .filter((prompt) => prompt.length > 0);
        };

        const focused = currentFocusedApp ? promptsForApp(currentFocusedApp) : [];
        if (focused.length) {
          return focused.slice(0, 4);
        }

        const merged = [];
        for (const appId of currentActiveApps) {
          const candidates = promptsForApp(appId);
          for (const suggestion of candidates) {
            if (!merged.includes(suggestion)) {
              merged.push(suggestion);
            }
            if (merged.length >= 3) {
              return merged;
            }
          }
        }

        if (merged.length) return merged;

        const catalogPrompts = [];
        for (const manifest of appCatalog.values()) {
          for (const suggestion of promptsForApp(manifest.id)) {
            if (!catalogPrompts.includes(suggestion)) {
              catalogPrompts.push(suggestion);
            }
            if (catalogPrompts.length >= 3) {
              return catalogPrompts;
            }
          }
        }

        return catalogPrompts.length ? catalogPrompts : DEFAULT_PROMPT_SUGGESTIONS;
      }

      function stopSuggestionCycle() {
        if (!suggestionCycleTimer) return;
        clearInterval(suggestionCycleTimer);
        suggestionCycleTimer = null;
      }

      function renderCurrentSuggestion(animate = false) {
        if (!promptSuggestionCurrentEl) return;
        if (!suggestionCycleItems.length) {
          promptSuggestionCurrentEl.textContent = '';
          promptSuggestionCurrentEl.disabled = true;
          return;
        }

        const suggestion = suggestionCycleItems[suggestionCycleIndex % suggestionCycleItems.length];
        promptSuggestionCurrentEl.disabled = false;
        promptSuggestionCurrentEl.textContent = suggestion;
        promptSuggestionCurrentEl.title = suggestion;
        promptSuggestionCurrentEl.onclick = () => {
          promptEl.value = suggestion;
          focusPromptInput();
        };

        if (animate && promptSuggestionCurrentEl.animate) {
          promptSuggestionCurrentEl.animate(
            [
              { opacity: 0.34, transform: 'translateY(1px)' },
              { opacity: 1, transform: 'translateY(0)' },
            ],
            { duration: 300, easing: 'ease-out' },
          );
        }
      }

      function startSuggestionCycle() {
        stopSuggestionCycle();
        if (suggestionCycleItems.length <= 1) return;
        suggestionCycleTimer = setInterval(() => {
          suggestionCycleIndex = (suggestionCycleIndex + 1) % suggestionCycleItems.length;
          renderCurrentSuggestion(true);
        }, 4300);
      }

      function renderPromptSuggestions() {
        if (!promptSuggestionCurrentEl || !suggestionTitleEl) return;
        suggestionTitleEl.textContent = hasRunPrompt ? 'Suggested prompt:' : 'Starter prompt:';
        const suggestions = resolvePromptSuggestions().slice(0, 4);
        const signature = suggestions.join('::');
        if (signature === suggestionSignature && suggestionCycleItems.length) return;
        suggestionSignature = signature;
        suggestionCycleItems = suggestions;
        suggestionCycleIndex = 0;
        renderCurrentSuggestion(false);
        startSuggestionCycle();
      }

      function iconForSurfaceAction(action) {
        if (action === 'minimize') {
          return '<svg viewBox="0 0 16 16" aria-hidden="true"><path d="M3 12.5h10"/></svg>';
        }
        if (action === 'restore') {
          return '<svg viewBox="0 0 16 16" aria-hidden="true"><rect x="2.5" y="5.5" width="8" height="8" rx="1"/><path d="M6 2.5h7.5V10"/><path d="M13.5 2.5L9 2.5"/></svg>';
        }
        return '<svg viewBox="0 0 16 16" aria-hidden="true"><path d="M2.5 6V2.5H6"/><path d="M10 2.5h3.5V6"/><path d="M13.5 10v3.5H10"/><path d="M6 13.5H2.5V10"/></svg>';
      }

      function getSurfaceControlDefinitions(windowMode) {
        const controls = [];
        if (windowMode !== 'minimized') {
          controls.push({ action: 'minimize', title: 'Minimize' });
        }
        if (windowMode !== 'normal') {
          controls.push({ action: 'restore', title: 'Restore' });
        }
        if (windowMode !== 'maximized') {
          controls.push({ action: 'maximize', title: 'Maximize' });
        }
        return controls;
      }

      function buildSurfaceControlsMarkup(windowMode) {
        return getSurfaceControlDefinitions(windowMode)
          .map(({ action, title }) => (
            `<button class="surface-btn" data-action="${action}" title="${title}" aria-label="${title}">${iconForSurfaceAction(action)}</button>`
          ))
          .join('');
      }

      function renderDock(activeApps, focusedApp) {
        dockEl.innerHTML = '';
        activeApps.forEach((appId, index) => {
          const manifest = appCatalog.get(appId);
          const btn = document.createElement('button');
          btn.className = `dock-btn ${focusedApp === appId ? 'active' : ''}`;
          btn.dataset.index = String(index);
          const name = manifest ? manifest.name : appId;
          btn.innerHTML = `
            <span class="dock-btn-icon">${appGlyph(name)}</span>
            <span class="dock-btn-label">${shortLabel(name)}</span>
          `;
          btn.onclick = () => sendEvent({ type: 'app_focus', app_id: appId });
          dockEl.appendChild(btn);
        });
        resetDockDepth();
      }

      function renderSurfaces() {
        surfacesEl.innerHTML = '';
        surfaceElements.clear();
        const activeSurfaceIds = new Set(surfaces.keys());
        for (const surfaceId of Array.from(surfaceWindowState.keys())) {
          if (!activeSurfaceIds.has(surfaceId)) {
            surfaceWindowState.delete(surfaceId);
          }
        }
        const sortedSurfaces = Array.from(surfaces.values()).sort((a, b) => {
          const az = getSurfaceBounds(a).z;
          const bz = getSurfaceBounds(b).z;
          return az - bz;
        });

        if (!sortedSurfaces.length) {
          surfacesEl.innerHTML = '<div class="surface-empty">No agent surfaces yet. Run a Master Prompt to compose your workspace.</div>';
          return;
        }

        let maxBottom = 640;
        let maxRight = stageEl ? stageEl.clientWidth : 900;

        for (const surface of sortedSurfaces) {
          const windowState = syncSurfaceWindowState(surface.id, surface);
          const windowMode = windowState.mode;
          const card = document.createElement('article');
          const isFocused = surface.app_id && surface.app_id === currentFocusedApp;
          card.className = `surface${isFocused ? ' active' : ''}${windowMode === 'minimized' ? ' minimized' : ''}`;
          card.dataset.appId = surface.app_id || '';
          card.dataset.surfaceId = surface.id;
          card.dataset.windowMode = windowMode;
          card.tabIndex = 0;

          applySurfaceStyles(card, surface);

          const title = surface.props?.title || surface.id;
          const content = surface.props?.content || 'Ready';
          const appLabel = surface.app_id || 'agent';
          card.innerHTML = `
            <div class="surface-head">
              <div class="surface-title">
                <h3>${title}</h3>
                <span class="surface-app">${appLabel}</span>
              </div>
              <div class="surface-controls">
                ${buildSurfaceControlsMarkup(windowMode)}
              </div>
            </div>
            <p>${content}</p>
          `;
          card.querySelectorAll('.surface-btn').forEach((button) => {
            const runSurfaceAction = (event) => {
              event.preventDefault();
              event.stopPropagation();
              const now = performance.now();
              const lastFired = Number(button.dataset.lastFiredAt || 0);
              if (now - lastFired < 120) return;
              button.dataset.lastFiredAt = String(now);
              const action = button.dataset.action;
              if (action) {
                applySurfaceWindowAction(surface.id, action);
              }
            };
            button.onpointerdown = (event) => {
              event.stopPropagation();
            };
            button.onpointerup = (event) => {
              event.stopPropagation();
            };
            button.onclick = runSurfaceAction;
          });
          card.onpointerdown = (event) => startSurfaceDrag(event, surface.id);
          card.onkeydown = (event) => {
            if (event.key !== 'Enter' && event.key !== ' ') return;
            event.preventDefault();
            if (surface.app_id) {
              focusApp(surface.app_id, true);
            }
          };
          card.onfocus = () => {
            if (surface.app_id && surface.app_id !== currentFocusedApp) {
              focusApp(surface.app_id, true);
            }
          };
          surfacesEl.appendChild(card);
          surfaceElements.set(surface.id, card);

          const { x, y, w, h } = getSurfaceBounds(surface);
          maxBottom = Math.max(maxBottom, y + h + 90);
          maxRight = Math.max(maxRight, x + w + 90);
        }

        const stageWidth = stageEl ? stageEl.clientWidth : maxRight;
        surfacesEl.style.minHeight = `${maxBottom}px`;
        surfacesEl.style.minWidth = `${Math.max(stageWidth, maxRight)}px`;
      }

      function setPendingApproval(payload) {
        pendingApproval = payload;
        if (!payload) {
          approvalTitleEl.textContent = 'No pending approval';
          approvalRiskEl.innerHTML = '';
          approveBtn.disabled = true;
          rejectBtn.disabled = true;
          return;
        }
        approvalTitleEl.textContent = payload.title;
        approvalRiskEl.innerHTML = `<span class="risk-badge risk-${payload.risk}">${payload.risk}</span>`;
        approveBtn.disabled = false;
        rejectBtn.disabled = false;
      }

      function setPolicyDecision(message, allowed = null) {
        if (!policyDecisionEl) return;
        policyDecisionEl.textContent = message || 'No policy decision yet';
        policyDecisionEl.className = 'policy-value';
        if (allowed === true) {
          policyDecisionEl.classList.add('ok');
          return;
        }
        if (allowed === false) {
          policyDecisionEl.classList.add('warn');
          return;
        }
        policyDecisionEl.classList.add('neutral');
      }

      async function loadApps() {
        const res = await fetch('/api/os/apps');
        const body = await res.json();
        for (const app of body.apps || []) {
          appCatalog.set(app.id, app);
        }
      }

      async function createSession() {
        const res = await fetch('/api/os/session', { method: 'POST' });
        const body = await res.json();
        sessionId = body.session_id;
        sessionEl.textContent = sessionId.slice(0, 8);
      }

      function connectStream() {
        if (stream) stream.close();
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
          reconnectTimer = null;
        }
        stream = new EventSource(`/api/os/stream/${sessionId}`);
        setStatus('connecting');
        trace('stream.connecting', { session_id: sessionId });

        const allEvents = [
          'shell_state', 'app_surface_ops', 'timeline_entry', 'approval_required',
          'notification', 'error', 'done', 'ping'
        ];

        for (const name of allEvents) {
          stream.addEventListener(name, (evt) => {
            const envelope = parseSseEnvelope(evt?.data, name);
            if (!envelope || typeof envelope !== 'object') return;
            const payload = envelope.payload;
            if (!payload || typeof payload !== 'object' || typeof payload.kind !== 'string') {
              return;
            }
            log(`sse.${name}`, payload);

            if (payload.kind === 'shell_state') {
              const data = payload.data;
              currentActiveApps = data.active_apps || [];
              currentFocusedApp = data.focused_app || null;
              renderDock(currentActiveApps, data.focused_app || null);
              focusedEl.textContent = `focused: ${data.focused_app || 'none'}`;
              renderSurfaces();
              renderPromptSuggestions();
            }

            if (payload.kind === 'app_surface_ops') {
              for (const op of payload.data.ops || []) {
                if (op.op === 'create') {
                  surfaces.set(op.id, op);
                  // Create ops are authoritative from server; clear stale local window mode
                  // so controls/drag behavior stays consistent across app switches.
                  surfaceWindowState.delete(op.id);
                }
                if (op.op === 'patch' && surfaces.has(op.id)) {
                  const existing = surfaces.get(op.id);
                  existing.props = { ...(existing.props || {}), ...(op.props || {}) };
                }
                if (op.op === 'remove') surfaces.delete(op.id);
              }
              renderSurfaces();
            }

            if (payload.kind === 'timeline_entry') {
              pushTimeline(payload.data.level, payload.data.message);
              const fields = payload.data.fields || {};
              if (typeof fields.policy_reason === 'string') {
                const allowed = fields.policy_allowed === true;
                setPolicyDecision(fields.policy_reason, allowed);
              }
            }

            if (payload.kind === 'approval_required') {
              setPendingApproval(payload.data);
              pushTimeline('warn', `Approval required for ${payload.data.app_id}`);
            }

            if (payload.kind === 'notification') {
              pushTimeline(payload.data.level, payload.data.message);
              const message = String(payload.data.message || '');
              if (message.toLowerCase().includes('policy')) {
                const allowed = payload.data.level !== 'warn';
                setPolicyDecision(message, allowed);
              }
            }

            if (payload.kind === 'done') {
              setStatus('done');
            }
            if (payload.kind === 'error') {
              setStatus('error');
            }
          });
        }

        stream.onopen = () => {
          reconnectAttempts = 0;
          setStatus('streaming');
          trace('stream.open', { session_id: sessionId });
        };

        stream.onerror = () => {
          setStatus('disconnected');
          trace('stream.error', {
            session_id: sessionId,
            reconnect_attempt_next: reconnectAttempts + 1,
          });
          if (stream) {
            stream.close();
            stream = null;
          }
          scheduleStreamReconnect();
        };
      }

      async function runPrompt(prompt) {
        const nextPrompt = String(prompt || '').trim();
        if (!nextPrompt) {
          pushTimeline('warn', 'Prompt is empty. Enter a request first.');
          return;
        }
        hasRunPrompt = true;
        renderPromptSuggestions();
        setStatus('running');
        runBtn.disabled = true;
        trace('prompt.start', {
          session_id: sessionId,
          prompt_preview: nextPrompt.slice(0, 140),
        });
        try {
          const res = await fetch(`/api/os/prompt/${sessionId}`, {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ prompt: nextPrompt }),
          });
          const body = await res.json();
          log('prompt.response', body);
          trace('prompt.end', {
            session_id: sessionId,
            ok: res.ok,
            status: res.status,
          });
        } catch (error) {
          setStatus('error');
          trace('prompt.error', {
            session_id: sessionId,
            message: String(error),
          });
          log('prompt.error', { message: String(error) });
        } finally {
          runBtn.disabled = false;
        }
      }

      async function sendEvent(event) {
        log('event.outbound', event);
        trace('event.send', {
          session_id: sessionId,
          type: event.type,
        });
        const res = await fetch(`/api/os/event/${sessionId}`, {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ seq: Date.now(), event }),
        });
        const body = await res.json();
        log('event.ack', body);
        trace('event.ack', {
          session_id: sessionId,
          type: event.type,
          ok: res.ok,
          status: res.status,
        });
      }

      runBtn.onclick = () => runPrompt(promptEl.value);
      promptEl.addEventListener('keydown', (event) => {
        if (event.key !== 'Enter') return;
        event.preventDefault();
        runPrompt(promptEl.value);
      });
      approveBtn.onclick = async () => {
        if (!pendingApproval) return;
        await sendEvent({
          type: 'approval_decision',
          action_id: pendingApproval.action_id,
          approved: true,
        });
        setPendingApproval(null);
      };

      let currentFocusedApp = null;
      let dragState = null;
      const dockButtons = () => Array.from(dockEl.querySelectorAll('.dock-btn'));

      function syncSurfaceFocusClasses() {
        surfaceElements.forEach((element, surfaceId) => {
          const surface = surfaces.get(surfaceId);
          const isFocused = Boolean(surface && surface.app_id && surface.app_id === currentFocusedApp);
          element.classList.toggle('active', isFocused);
        });
      }

      function focusApp(appId, emit = true) {
        if (!appId) return;
        currentFocusedApp = appId;
        focusedEl.textContent = `focused: ${appId}`;
        renderDock(currentActiveApps, currentFocusedApp);
        syncSurfaceFocusClasses();
        renderPromptSuggestions();
        if (emit) {
          sendEvent({ type: 'app_focus', app_id: appId });
        }
      }

      function focusPromptInput() {
        promptEl.focus();
        promptEl.select();
      }

      function cycleFocusedApp(direction) {
        if (!currentActiveApps.length) return;
        const currentIndex = currentActiveApps.indexOf(currentFocusedApp || '');
        const base = currentIndex >= 0 ? currentIndex : 0;
        const nextIndex = (base + direction + currentActiveApps.length) % currentActiveApps.length;
        focusApp(currentActiveApps[nextIndex], true);
      }

      function isEditableTarget(target) {
        if (!(target instanceof HTMLElement)) return false;
        const tag = target.tagName.toLowerCase();
        return tag === 'input' || tag === 'textarea' || target.isContentEditable;
      }

      function normalizeSurfaceZOrder(activeSurfaceId = null) {
        const ordered = Array.from(surfaces.values())
          .sort((a, b) => {
            const az = getSurfaceBounds(a).z;
            const bz = getSurfaceBounds(b).z;
            return az - bz || a.id.localeCompare(b.id);
          });

        let rank = 1;
        for (const surface of ordered) {
          if (activeSurfaceId && surface.id === activeSurfaceId) {
            continue;
          }
          surface.props = {
            ...(surface.props || {}),
            z_index: rank,
          };
          const element = surfaceElements.get(surface.id);
          if (element) {
            applySurfaceStyles(element, surface);
          }
          rank += 1;
        }

        if (!activeSurfaceId) return rank - 1;

        const active = surfaces.get(activeSurfaceId);
        if (!active) return rank - 1;
        active.props = {
          ...(active.props || {}),
          z_index: rank,
        };
        const activeElement = surfaceElements.get(activeSurfaceId);
        if (activeElement) {
          applySurfaceStyles(activeElement, active);
        }
        return rank;
      }

      function bringSurfaceToFront(surfaceId) {
        const surface = surfaces.get(surfaceId);
        if (!surface) return false;
        if (surfaces.size <= 1) {
          return false;
        }

        let topSurfaceId = null;
        let topZ = Number.NEGATIVE_INFINITY;
        surfaces.forEach((candidate) => {
          const candidateZ = getSurfaceBounds(candidate).z;
          if (candidateZ >= topZ) {
            topZ = candidateZ;
            topSurfaceId = candidate.id;
          }
        });

        if (topSurfaceId === surfaceId) {
          return false;
        }

        normalizeSurfaceZOrder(surfaceId);
        return true;
      }

      function emitWorkspaceLayoutChange() {
        const layout = JSON.stringify(serializeSurfaceLayout());
        sendEvent({ type: 'workspace_layout_change', layout });
      }

      function startSurfaceDrag(event, surfaceId) {
        if (event.button !== 0) return;
        const surface = surfaces.get(surfaceId);
        const card = surfaceElements.get(surfaceId);
        if (!surface || !card) return;
        if (event.target && event.target.closest && event.target.closest('.surface-controls')) return;

        const windowState = syncSurfaceWindowState(surfaceId, surface);
        if (windowState.mode === 'maximized') {
          if (windowState.restoreRect) {
            const restore = { ...windowState.restoreRect };
            const constrained = constrainSurfacePosition(
              surface,
              restore.x,
              restore.y,
              true,
            );
            surface.props = {
              ...(surface.props || {}),
              x: constrained.x,
              y: constrained.y,
              w: restore.w,
              h: restore.h,
            };
            windowState.mode = 'normal';
            renderSurfaces();
          } else {
            return;
          }
        }

        event.preventDefault();

        const { x, y } = getSurfaceBounds(surface);
        const zChanged = bringSurfaceToFront(surfaceId);
        if (surface.app_id) {
          focusApp(surface.app_id, true);
        }

        dragState = {
          surfaceId,
          pointerId: event.pointerId,
          startX: event.clientX,
          startY: event.clientY,
          originX: x,
          originY: y,
          moved: false,
          layoutDirty: zChanged,
        };

        if (card.setPointerCapture) {
          card.setPointerCapture(event.pointerId);
        }
        card.classList.add('dragging');
      }

      function onSurfacePointerMove(event) {
        if (!dragState || dragState.pointerId !== event.pointerId) return;
        const surface = surfaces.get(dragState.surfaceId);
        const card = surfaceElements.get(dragState.surfaceId);
        if (!surface || !card) return;

        const dx = event.clientX - dragState.startX;
        const dy = event.clientY - dragState.startY;
        if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
          dragState.moved = true;
        }

        const next = constrainSurfacePosition(
          surface,
          dragState.originX + dx,
          dragState.originY + dy,
          false,
        );
        surface.props = {
          ...(surface.props || {}),
          x: next.x,
          y: next.y,
        };
        applySurfaceStyles(card, surface, 8);
        dragState.layoutDirty = true;
      }

      function finishSurfaceDrag(event) {
        if (!dragState || dragState.pointerId !== event.pointerId) return;
        const state = dragState;
        dragState = null;

        const surface = surfaces.get(state.surfaceId);
        const card = surfaceElements.get(state.surfaceId);
        if (surface && card) {
          const current = getSurfaceBounds(surface);
          const snapped = constrainSurfacePosition(surface, current.x, current.y, true);
          card.classList.remove('dragging');
          surface.props = {
            ...(surface.props || {}),
            x: snapped.x,
            y: snapped.y,
          };
          if (snapped.x !== current.x || snapped.y !== current.y) {
            state.layoutDirty = true;
          }
          const windowState = surfaceWindowState.get(state.surfaceId);
          if (windowState) {
            if (windowState.mode === 'normal') {
              windowState.restoreRect = {
                x: snapped.x,
                y: snapped.y,
                w: current.w,
                h: current.h,
              };
            } else if (windowState.mode === 'minimized' && windowState.restoreRect) {
              windowState.restoreRect = {
                ...windowState.restoreRect,
                x: snapped.x,
                y: snapped.y,
              };
            }
          }
          applySurfaceStyles(card, surface);
          if (card.releasePointerCapture && card.hasPointerCapture(state.pointerId)) {
            card.releasePointerCapture(state.pointerId);
          }
        }
        if (state.layoutDirty) {
          emitWorkspaceLayoutChange();
        }
      }

      function resetDockDepth() {
        dockButtons().forEach((btn, index) => {
          btn.style.setProperty('--dock-depth', `${index * 1.6}px`);
          btn.style.setProperty('--dock-tilt-x', '0deg');
          btn.style.setProperty('--dock-tilt-y', '0deg');
        });
      }

      function resetSidebarDepth() {
        sidebarPanels.forEach((panel, index) => {
          const depth = sidebarDepths[index] || 0;
          const offset = sidebarOffsets[index] || 0;
          panel.style.setProperty('--depth', `${depth}px`);
          panel.style.setProperty('--offset', `${offset}px`);
          panel.style.setProperty('--tilt-x', '0deg');
          panel.style.setProperty('--tilt-y', `${sidebarYawBase[index] || 0}deg`);
          panel.style.setProperty('--mx', '50%');
          panel.style.setProperty('--my', '14%');
          panel.style.animationDelay = `${index * -1.3}s`;
        });
      }

      if (workspaceEl) {
        workspaceEl.addEventListener('pointermove', (event) => {
          if (!stageEl || window.innerWidth <= 1200) return;
          const bounds = stageEl.getBoundingClientRect();
          const px = ((event.clientX - bounds.left) / bounds.width) - 0.5;
          const py = ((event.clientY - bounds.top) / bounds.height) - 0.5;
          surfacesEl.style.transform = `rotateX(${(-py * 2.4).toFixed(2)}deg) rotateY(${(px * 3.2).toFixed(2)}deg)`;
        });
        workspaceEl.addEventListener('pointerleave', () => {
          surfacesEl.style.transform = 'rotateX(0deg) rotateY(0deg)';
        });
      }
      window.addEventListener('pointermove', onSurfacePointerMove);
      window.addEventListener('pointerup', finishSurfaceDrag);
      window.addEventListener('pointercancel', finishSurfaceDrag);

      if (sidebarEl) {
        resetSidebarDepth();
        sidebarEl.addEventListener('pointermove', (event) => {
          if (window.innerWidth <= 1200) return;
          const bounds = sidebarEl.getBoundingClientRect();
          const px = ((event.clientX - bounds.left) / bounds.width) - 0.5;
          const py = ((event.clientY - bounds.top) / bounds.height) - 0.5;
          sidebarPanels.forEach((panel, index) => {
            const rect = panel.getBoundingClientRect();
            const localX = clamp(((event.clientX - rect.left) / rect.width) * 100, 0, 100);
            const localY = clamp(((event.clientY - rect.top) / rect.height) * 100, 0, 100);
            const depth = sidebarDepths[index] || 0;
            const offset = sidebarOffsets[index] || 0;
            const yaw = (sidebarYawBase[index] || 0) + px * (1.6 + (index * 0.3));
            const pitch = -py * (1.2 + (index * 0.2));
            const hoverLift = 1 + (index * 0.3);
            panel.style.setProperty('--depth', `${depth + hoverLift}px`);
            panel.style.setProperty('--offset', `${offset}px`);
            panel.style.setProperty('--tilt-x', `${pitch.toFixed(2)}deg`);
            panel.style.setProperty('--tilt-y', `${yaw.toFixed(2)}deg`);
            panel.style.setProperty('--mx', `${localX.toFixed(2)}%`);
            panel.style.setProperty('--my', `${localY.toFixed(2)}%`);
          });
        });
        sidebarEl.addEventListener('pointerleave', () => {
          resetSidebarDepth();
        });
      }
      if (dockEl) {
        dockEl.addEventListener('pointermove', (event) => {
          if (window.innerWidth <= 1200) return;
          const rail = dockEl.getBoundingClientRect();
          const railPx = ((event.clientX - rail.left) / rail.width) - 0.5;
          const railPy = ((event.clientY - rail.top) / rail.height) - 0.5;
          dockButtons().forEach((btn, index) => {
            const rect = btn.getBoundingClientRect();
            const cx = rect.left + (rect.width / 2);
            const cy = rect.top + (rect.height / 2);
            const distance = Math.hypot(event.clientX - cx, event.clientY - cy);
            const influence = clamp(1 - (distance / 180), 0, 1);
            const depth = (index * 1.6) + (influence * 14);
            const tiltX = (-railPy * 3.6 * influence).toFixed(2);
            const tiltY = (railPx * 4.4 * influence).toFixed(2);
            btn.style.setProperty('--dock-depth', `${depth.toFixed(2)}px`);
            btn.style.setProperty('--dock-tilt-x', `${tiltX}deg`);
            btn.style.setProperty('--dock-tilt-y', `${tiltY}deg`);
          });
        });
        dockEl.addEventListener('pointerleave', () => {
          resetDockDepth();
        });
      }
      window.addEventListener('keydown', (event) => {
        const withMeta = event.metaKey || event.ctrlKey;
        if (!withMeta) return;

        if (event.key.toLowerCase() === 'k') {
          event.preventDefault();
          focusPromptInput();
          return;
        }

        if (isEditableTarget(event.target)) {
          return;
        }

        if (event.key === ']') {
          event.preventDefault();
          cycleFocusedApp(1);
          return;
        }

        if (event.key === '[') {
          event.preventDefault();
          cycleFocusedApp(-1);
        }
      });
      rejectBtn.onclick = async () => {
        if (!pendingApproval) return;
        await sendEvent({
          type: 'approval_decision',
          action_id: pendingApproval.action_id,
          approved: false,
        });
        setPendingApproval(null);
      };

      (async () => {
        try {
          setServerInfo();
          trace('boot.start');
          await loadApps();
          await createSession();
          setPolicyDecision('No policy decision yet', null);
          renderPromptSuggestions();
          connectStream();
          pushTimeline('info', 'Shell ready. Submit a Master Prompt.');
          trace('boot.ready', { session_id: sessionId });
        } catch (error) {
          setStatus('error');
          trace('boot.error', { message: String(error) });
          log('boot.error', { message: String(error) });
        }
      })();
    </script>
  </body>
</html>
