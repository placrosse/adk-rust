<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ADK Spatial OS</title>
    <style>
      :root {
        --bg: #f4f6fb;
        --panel: #ffffff;
        --text: #131927;
        --muted: #5f6d87;
        --line: #dbe2ef;
        --brand: #1554f6;
        --brand-soft: #e8eeff;
        --success: #08785d;
        --warn: #b86307;
        --danger: #b22243;
        --shell-edge: #d0d8ea;
        --dock-width: 104px;
        --side-width: 360px;
        --shell-gap: 14px;
        --shell-pad: 20px;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        background:
          radial-gradient(1200px 460px at 20% -5%, rgba(96, 125, 255, 0.16), transparent 60%),
          radial-gradient(960px 520px at 92% 10%, rgba(28, 201, 152, 0.14), transparent 62%),
          linear-gradient(180deg, #f8fbff 0%, #eef2f8 100%);
        color: var(--text);
        font-family: "IBM Plex Sans", "Segoe UI", system-ui, -apple-system, sans-serif;
      }
      .shell {
        min-height: 100vh;
        display: grid;
        grid-template-rows: auto 1fr;
      }
      .topbar {
        border-bottom: 1px solid var(--line);
        background: rgba(255,255,255,0.88);
        backdrop-filter: blur(10px);
        position: sticky;
        top: 0;
        z-index: 10;
      }
      .topbar-inner {
        width: 100%;
        padding: 14px var(--shell-pad);
        display: grid;
        grid-template-columns: var(--dock-width) minmax(0, 1fr) var(--side-width);
        gap: var(--shell-gap);
        align-items: center;
      }
      .topbar-spacer {
        width: 100%;
        height: 100%;
      }
      .topbar-main {
        display: grid;
        grid-template-columns: 290px minmax(0, 1fr);
        gap: 12px;
        align-items: center;
      }
      .brand h1 {
        margin: 0;
        font-size: 23px;
        letter-spacing: 0.02em;
      }
      .brand p {
        margin: 2px 0 0;
        color: var(--muted);
        font-size: 13px;
      }
      .master-prompt {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
        align-items: center;
      }
      .master-prompt input {
        width: 100%;
        padding: 13px 14px;
        border-radius: 12px;
        border: 1px solid var(--line);
        background: #fff;
        color: var(--text);
        font-size: 15px;
      }
      .master-prompt button {
        border: none;
        border-radius: 12px;
        padding: 0 20px;
        background: var(--brand);
        color: #fff;
        font-weight: 600;
        cursor: pointer;
      }
      .master-prompt input:focus-visible,
      .master-prompt button:focus-visible,
      .dock-btn:focus-visible,
      .surface:focus-visible,
      .actions button:focus-visible {
        outline: none;
        border-color: rgba(21, 84, 246, 0.75);
        box-shadow:
          0 0 0 3px rgba(21, 84, 246, 0.22),
          0 1px 0 rgba(255, 255, 255, 0.9) inset;
      }
      .status-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        justify-self: stretch;
      }
      .stat {
        background: #fff;
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px 10px;
      }
      .stat .k { font-size: 11px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.08em; }
      .stat .v { margin-top: 2px; font-size: 18px; font-weight: 700; }

      .body {
        width: 100%;
        padding: 14px var(--shell-pad) 20px;
        display: grid;
        grid-template-columns: var(--dock-width) minmax(0, 1fr) var(--side-width);
        gap: var(--shell-gap);
        min-height: calc(100vh - 84px);
        align-items: start;
      }
      .dock {
        position: relative;
        background: rgba(255, 255, 255, 0.78);
        border: 1px solid var(--shell-edge);
        border-radius: 16px;
        padding: 10px 8px 14px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: center;
        backdrop-filter: blur(8px);
        perspective: 900px;
        overflow: hidden;
      }
      .dock::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: inherit;
        background:
          radial-gradient(110% 65% at 0% 8%, rgba(42, 113, 255, 0.14), transparent 62%),
          linear-gradient(180deg, rgba(255, 255, 255, 0.58) 0%, rgba(255, 255, 255, 0) 52%);
        pointer-events: none;
      }
      .dock-btn {
        --dock-tilt-x: 0deg;
        --dock-tilt-y: 0deg;
        --dock-depth: 0px;
        width: 74px;
        min-height: 66px;
        border: 1px solid var(--line);
        border-radius: 14px;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.98) 0%, rgba(244, 248, 255, 0.96) 100%);
        cursor: pointer;
        font-size: 11px;
        color: var(--muted);
        padding: 8px 6px 7px;
        display: grid;
        justify-items: center;
        align-content: center;
        gap: 6px;
        position: relative;
        transform-style: preserve-3d;
        transform: translate3d(0, 0, var(--dock-depth)) rotateX(var(--dock-tilt-x)) rotateY(var(--dock-tilt-y));
        box-shadow:
          0 10px 20px rgba(19, 36, 74, 0.12),
          0 1px 0 rgba(255, 255, 255, 0.82) inset;
        transition: transform 170ms ease, border-color 170ms ease, box-shadow 170ms ease, color 170ms ease;
        z-index: 1;
      }
      .dock-btn::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: inherit;
        background: radial-gradient(120% 75% at 50% 0%, rgba(255, 255, 255, 0.65), transparent 65%);
        pointer-events: none;
      }
      .dock-btn:hover {
        --dock-depth: 10px;
        border-color: rgba(21, 84, 246, 0.38);
        color: #3a568f;
        box-shadow:
          0 16px 26px rgba(19, 36, 74, 0.18),
          0 1px 0 rgba(255, 255, 255, 0.9) inset;
      }
      .dock-btn-icon {
        width: 28px;
        height: 28px;
        border-radius: 9px;
        display: grid;
        place-items: center;
        font-size: 12px;
        font-weight: 700;
        color: #49608f;
        background: #ebf1ff;
        border: 1px solid #d8e4ff;
      }
      .dock-btn-label {
        display: block;
        max-width: 62px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        line-height: 1;
      }
      .dock-btn.active {
        border-color: var(--brand);
        background: var(--brand-soft);
        color: var(--brand);
        --dock-depth: 14px;
        box-shadow:
          0 18px 28px rgba(21, 84, 246, 0.2),
          0 0 0 1px rgba(21, 84, 246, 0.22);
      }
      .dock-btn.active .dock-btn-icon {
        color: #ffffff;
        background: #2d6bfa;
        border-color: #2d6bfa;
      }

      .workspace {
        background: rgba(255, 255, 255, 0.78);
        border: 1px solid var(--shell-edge);
        border-radius: 18px;
        padding: 14px;
        display: grid;
        grid-template-rows: auto 1fr;
        gap: 10px;
        min-height: 0;
        backdrop-filter: blur(9px);
      }
      .workspace-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .workspace-header h2 { margin: 0; font-size: 20px; }
      .workspace-header span {
        font-size: 12px;
        color: var(--muted);
      }
      .spatial-stage {
        position: relative;
        border: 1px solid var(--line);
        border-radius: 14px;
        background:
          linear-gradient(160deg, rgba(255, 255, 255, 0.93) 0%, rgba(241, 246, 255, 0.95) 100%);
        overflow: auto;
        perspective: 1450px;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.75);
      }
      .spatial-plane {
        position: relative;
        min-height: 780px;
        min-width: 100%;
        transform-style: preserve-3d;
        transition: transform 180ms ease-out;
        background:
          linear-gradient(rgba(27, 50, 94, 0.04) 1px, transparent 1px),
          linear-gradient(90deg, rgba(27, 50, 94, 0.04) 1px, transparent 1px);
        background-size: 36px 36px;
      }
      .surface {
        position: absolute;
        border: 1px solid rgba(169, 186, 220, 0.9);
        border-radius: 16px;
        padding: 12px;
        background:
          linear-gradient(180deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 251, 255, 0.96) 100%);
        box-shadow:
          0 20px 34px rgba(21, 34, 66, 0.14),
          0 1px 0 rgba(255, 255, 255, 0.84) inset;
        transform-origin: center center;
        transition: transform 220ms ease, box-shadow 220ms ease, border-color 220ms ease;
        cursor: grab;
        user-select: none;
        touch-action: none;
      }
      .surface.dragging {
        cursor: grabbing;
        transition: none;
      }
      .surface:hover {
        transform: translateZ(26px) scale(1.01);
        box-shadow:
          0 28px 42px rgba(21, 34, 66, 0.2),
          0 1px 0 rgba(255, 255, 255, 0.9) inset;
      }
      .surface.active {
        border-color: rgba(21, 84, 246, 0.78);
        box-shadow:
          0 34px 48px rgba(21, 84, 246, 0.22),
          0 0 0 1px rgba(21, 84, 246, 0.23);
      }
      .surface-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }
      .surface h3 {
        margin: 0;
        font-size: 16px;
      }
      .surface p {
        margin: 6px 0 0;
        color: var(--muted);
        font-size: 13px;
        line-height: 1.45;
      }
      .surface-app {
        font-size: 11px;
        color: #47639e;
        background: #eaf0ff;
        border-radius: 999px;
        padding: 3px 8px;
        max-width: 160px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .surface-empty {
        padding: 26px;
        color: var(--muted);
        text-align: center;
        font-weight: 600;
      }

      .sidebar {
        position: relative;
        display: grid;
        gap: 12px;
        align-content: start;
        min-height: 0;
        perspective: 1200px;
        transform-style: preserve-3d;
      }
      .sidebar::before {
        content: "";
        position: absolute;
        inset: 8px 6px;
        border-radius: 16px;
        pointer-events: none;
        background:
          radial-gradient(90% 45% at 10% 12%, rgba(49, 121, 255, 0.14), transparent 62%),
          radial-gradient(86% 44% at 85% 88%, rgba(20, 188, 151, 0.13), transparent 66%);
        filter: blur(12px);
        z-index: 0;
      }
      .panel {
        --tilt-x: 0deg;
        --tilt-y: 0deg;
        --depth: 0px;
        --offset: 0px;
        --mx: 50%;
        --my: 14%;
        position: relative;
        background: rgba(255, 255, 255, 0.78);
        border: 1px solid var(--shell-edge);
        border-radius: 14px;
        padding: 10px;
        backdrop-filter: blur(9px);
        overflow: hidden;
        box-shadow:
          0 16px 28px rgba(16, 33, 73, 0.12),
          0 1px 0 rgba(255, 255, 255, 0.86) inset;
        transform-style: preserve-3d;
        transform: translate3d(var(--offset), 0, var(--depth)) rotateX(var(--tilt-x)) rotateY(var(--tilt-y));
        transition: border-color 220ms ease, box-shadow 220ms ease, transform 220ms ease;
        will-change: transform;
        z-index: 1;
        animation: panelFloat 8.5s ease-in-out infinite;
      }
      .panel::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: inherit;
        background:
          radial-gradient(140% 80% at var(--mx) var(--my), rgba(255, 255, 255, 0.72), rgba(255, 255, 255, 0) 56%),
          linear-gradient(150deg, rgba(255, 255, 255, 0.52) 0%, rgba(255, 255, 255, 0) 62%);
        pointer-events: none;
      }
      .panel::after {
        content: "";
        position: absolute;
        left: 14px;
        right: 14px;
        bottom: -14px;
        height: 18px;
        border-radius: 999px;
        background: rgba(24, 45, 95, 0.14);
        filter: blur(10px);
        opacity: 0.5;
        pointer-events: none;
        transition: opacity 220ms ease;
      }
      .panel:hover {
        border-color: rgba(21, 84, 246, 0.38);
        box-shadow:
          0 24px 38px rgba(16, 33, 73, 0.18),
          0 1px 0 rgba(255, 255, 255, 0.9) inset;
      }
      .panel:hover::after {
        opacity: 0.68;
      }
      .panel:nth-child(1) { z-index: 4; }
      .panel:nth-child(2) { z-index: 3; }
      .panel:nth-child(3) { z-index: 2; }
      .panel > * {
        position: relative;
        z-index: 2;
        transform: translateZ(14px);
      }
      .panel h3 {
        margin: 0 0 8px;
        font-size: 16px;
        transform: translateZ(20px);
      }
      .timeline {
        max-height: 300px;
        overflow: auto;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .entry {
        border: 1px solid var(--line);
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.9);
        padding: 8px;
      }
      .entry .lvl {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: var(--muted);
      }
      .entry .msg {
        margin-top: 4px;
        font-size: 13px;
      }
      .trust {
        display: grid;
        gap: 8px;
      }
      .risk-badge {
        display: inline-block;
        border-radius: 999px;
        padding: 4px 8px;
        font-size: 11px;
        font-weight: 700;
      }
      .risk-dangerous { background: #ffe8ee; color: var(--danger); }
      .risk-controlled { background: #fff1de; color: var(--warn); }
      .risk-safe { background: #e6faf1; color: var(--success); }
      .actions {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }
      .actions button {
        border: none;
        border-radius: 10px;
        padding: 10px;
        font-weight: 600;
        cursor: pointer;
      }
      .approve { background: #0f9e79; color: #fff; }
      .reject { background: #eb486f; color: #fff; }
      .approve:disabled, .reject:disabled { opacity: 0.5; cursor: not-allowed; }
      .log {
        max-height: 220px;
        overflow: auto;
        white-space: pre-wrap;
        background: rgba(244, 248, 255, 0.84);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        font-size: 12px;
      }
      @keyframes panelFloat {
        0% { transform: translate3d(var(--offset), 0px, var(--depth)) rotateX(var(--tilt-x)) rotateY(var(--tilt-y)); }
        50% { transform: translate3d(var(--offset), -2px, calc(var(--depth) + 2px)) rotateX(var(--tilt-x)) rotateY(var(--tilt-y)); }
        100% { transform: translate3d(var(--offset), 0px, var(--depth)) rotateX(var(--tilt-x)) rotateY(var(--tilt-y)); }
      }
      @media (prefers-reduced-motion: reduce) {
        .panel, .surface, .spatial-plane {
          animation: none !important;
          transition: none !important;
        }
      }
      @media (max-width: 1200px) {
        .topbar-inner {
          grid-template-columns: 1fr;
          gap: 10px;
        }
        .topbar-spacer {
          display: none;
        }
        .topbar-main {
          grid-template-columns: 1fr;
          gap: 10px;
        }
        .body { grid-template-columns: 1fr; }
        .dock {
          flex-direction: row;
          justify-content: start;
          overflow-x: auto;
          padding: 10px;
        }
        .dock-btn {
          min-width: 74px;
        }
        .spatial-plane {
          min-height: 560px;
          padding: 10px;
          background: none;
        }
        .surface {
          position: relative;
          left: auto !important;
          top: auto !important;
          width: auto !important;
          height: auto !important;
          transform: none !important;
          margin-bottom: 10px;
        }
        .panel {
          animation: none !important;
          transform: none !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <header class="topbar">
        <div class="topbar-inner">
          <div class="topbar-spacer" aria-hidden="true"></div>
          <div class="topbar-main">
            <div class="brand">
              <h1>ADK Spatial OS</h1>
              <p>Agent-native desktop shell</p>
            </div>
            <div class="master-prompt">
              <input id="prompt" value="Summarize platform health and propose safe mitigation options." />
              <button id="run">Run</button>
            </div>
          </div>
          <div class="status-grid">
            <div class="stat"><div class="k">Session</div><div class="v" id="session">n/a</div></div>
            <div class="stat"><div class="k">Status</div><div class="v" id="status">idle</div></div>
          </div>
        </div>
      </header>

      <main class="body">
        <aside class="dock" id="dock"></aside>

        <section class="workspace">
          <div class="workspace-header">
            <h2>Spatial Workspace</h2>
            <span id="focused">focused: none</span>
          </div>
          <div class="spatial-stage">
            <div id="surfaces" class="spatial-plane"></div>
          </div>
        </section>

        <aside class="sidebar">
          <section class="panel">
            <h3>Trust Panel</h3>
            <div class="trust">
              <div id="approvalTitle">No pending approval</div>
              <div id="approvalRisk"></div>
              <div class="actions">
                <button id="approve" class="approve" disabled>Approve</button>
                <button id="reject" class="reject" disabled>Reject</button>
              </div>
            </div>
          </section>

          <section class="panel">
            <h3>Timeline</h3>
            <div id="timeline" class="timeline"></div>
          </section>

          <section class="panel">
            <h3>Runtime Log</h3>
            <div id="log" class="log"></div>
          </section>
        </aside>
      </main>
    </div>

    <script>
      const statusEl = document.getElementById('status');
      const sessionEl = document.getElementById('session');
      const promptEl = document.getElementById('prompt');
      const runBtn = document.getElementById('run');
      const dockEl = document.getElementById('dock');
      const surfacesEl = document.getElementById('surfaces');
      const stageEl = document.querySelector('.spatial-stage');
      const workspaceEl = document.querySelector('.workspace');
      const sidebarEl = document.querySelector('.sidebar');
      const focusedEl = document.getElementById('focused');
      const timelineEl = document.getElementById('timeline');
      const logEl = document.getElementById('log');
      const approvalTitleEl = document.getElementById('approvalTitle');
      const approvalRiskEl = document.getElementById('approvalRisk');
      const approveBtn = document.getElementById('approve');
      const rejectBtn = document.getElementById('reject');

      let sessionId = null;
      let stream = null;
      let pendingApproval = null;
      const appCatalog = new Map();
      const surfaces = new Map();
      const surfaceElements = new Map();
      const SURFACE_GRID_SIZE = 24;
      const STAGE_EDGE_PADDING = 18;
      const sidebarPanels = Array.from(document.querySelectorAll('.sidebar .panel'));
      const sidebarDepths = sidebarPanels.map((_, index) => Math.max(0, 20 - (index * 6)));
      const sidebarOffsets = sidebarPanels.map((_, index) => {
        if (index === 0) return -6;
        if (index === 1) return 2;
        return 10;
      });
      const sidebarYawBase = sidebarPanels.map((_, index) => {
        if (index === 0) return -0.9;
        if (index === 1) return -0.15;
        return 0.7;
      });
      let currentActiveApps = [];

      function setStatus(value) { statusEl.textContent = value; }
      const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
      const shortLabel = (name) => {
        if (!name) return 'App';
        return name.length > 9 ? `${name.slice(0, 8)}...` : name;
      };
      const appGlyph = (name) => {
        if (!name) return 'A';
        return name
          .split(/\s+/)
          .filter(Boolean)
          .slice(0, 2)
          .map((part) => part[0].toUpperCase())
          .join('');
      };
      const readNum = (value, fallback) => {
        const n = typeof value === 'string' ? parseFloat(value) : Number(value);
        return Number.isFinite(n) ? n : fallback;
      };
      const snapToGrid = (value, grid = SURFACE_GRID_SIZE) => Math.round(value / grid) * grid;
      const getStageBoundsForSize = (w, h) => {
        const stageWidth = Math.max(
          stageEl ? stageEl.clientWidth : 0,
          surfacesEl ? surfacesEl.scrollWidth : 0,
          readNum(surfacesEl?.style?.minWidth, 0),
        );
        const stageHeight = Math.max(
          stageEl ? stageEl.clientHeight : 0,
          surfacesEl ? surfacesEl.scrollHeight : 0,
          readNum(surfacesEl?.style?.minHeight, 0),
        );
        const minX = STAGE_EDGE_PADDING;
        const minY = STAGE_EDGE_PADDING;
        const maxX = Math.max(minX, stageWidth - w - STAGE_EDGE_PADDING);
        const maxY = Math.max(minY, stageHeight - h - STAGE_EDGE_PADDING);
        return { minX, minY, maxX, maxY };
      };
      const constrainSurfacePosition = (surface, x, y, snap = false) => {
        const { w, h } = getSurfaceBounds(surface);
        const bounds = getStageBoundsForSize(w, h);
        const nx = snap ? snapToGrid(x) : x;
        const ny = snap ? snapToGrid(y) : y;
        return {
          x: Math.round(clamp(nx, bounds.minX, bounds.maxX)),
          y: Math.round(clamp(ny, bounds.minY, bounds.maxY)),
        };
      };
      const getSurfaceBounds = (surface) => ({
        x: readNum(surface?.props?.x, 48),
        y: readNum(surface?.props?.y, 56),
        w: readNum(surface?.props?.w, 420),
        h: readNum(surface?.props?.h, 280),
        z: readNum(surface?.props?.z_index, 10),
      });
      const surfaceTransform = (surface, lift = 0) => {
        const { z } = getSurfaceBounds(surface);
        const depth = Math.max(0, z - 8) * 14;
        const skew = ((z % 3) - 1) * 0.4;
        return `translate3d(0, 0, ${depth + lift}px) rotateX(0.45deg) rotateY(${skew}deg)`;
      };
      function applySurfaceStyles(card, surface, lift = 0) {
        const { x, y, w, h, z } = getSurfaceBounds(surface);
        card.style.left = `${x}px`;
        card.style.top = `${y}px`;
        card.style.width = `${w}px`;
        card.style.height = `${h}px`;
        card.style.zIndex = String(z);
        card.style.transform = surfaceTransform(surface, lift);
      }
      function serializeSurfaceLayout() {
        return Array.from(surfaces.values())
          .map((surface) => {
            const { x, y, w, h, z } = getSurfaceBounds(surface);
            return {
              id: surface.id,
              app_id: surface.app_id || '',
              x,
              y,
              w,
              h,
              z_index: z,
            };
          })
          .sort((a, b) => a.id.localeCompare(b.id));
      }
      function log(label, data) {
        const line = `[${new Date().toISOString()}] ${label}${data ? `\n${JSON.stringify(data, null, 2)}` : ''}`;
        logEl.textContent = `${line}\n\n${logEl.textContent}`;
      }
      function pushTimeline(level, message) {
        const item = document.createElement('div');
        item.className = 'entry';
        item.innerHTML = `<div class="lvl">${level}</div><div class="msg">${message}</div>`;
        timelineEl.prepend(item);
      }

      function renderDock(activeApps, focusedApp) {
        dockEl.innerHTML = '';
        activeApps.forEach((appId, index) => {
          const manifest = appCatalog.get(appId);
          const btn = document.createElement('button');
          btn.className = `dock-btn ${focusedApp === appId ? 'active' : ''}`;
          btn.dataset.index = String(index);
          const name = manifest ? manifest.name : appId;
          btn.innerHTML = `
            <span class="dock-btn-icon">${appGlyph(name)}</span>
            <span class="dock-btn-label">${shortLabel(name)}</span>
          `;
          btn.onclick = () => sendEvent({ type: 'app_focus', app_id: appId });
          dockEl.appendChild(btn);
        });
        resetDockDepth();
      }

      function renderSurfaces() {
        surfacesEl.innerHTML = '';
        surfaceElements.clear();
        const sortedSurfaces = Array.from(surfaces.values()).sort((a, b) => {
          const az = getSurfaceBounds(a).z;
          const bz = getSurfaceBounds(b).z;
          return az - bz;
        });

        if (!sortedSurfaces.length) {
          surfacesEl.innerHTML = '<div class="surface-empty">No agent surfaces yet. Run a Master Prompt to compose your workspace.</div>';
          return;
        }

        let maxBottom = 640;
        let maxRight = stageEl ? stageEl.clientWidth : 900;

        for (const surface of sortedSurfaces) {
          const card = document.createElement('article');
          const isFocused = surface.app_id && surface.app_id === currentFocusedApp;
          card.className = `surface${isFocused ? ' active' : ''}`;
          card.dataset.appId = surface.app_id || '';
          card.dataset.surfaceId = surface.id;
          card.tabIndex = 0;

          applySurfaceStyles(card, surface);

          const title = surface.props?.title || surface.id;
          const content = surface.props?.content || 'Ready';
          const appLabel = surface.app_id || 'agent';
          card.innerHTML = `
            <div class="surface-head">
              <h3>${title}</h3>
              <span class="surface-app">${appLabel}</span>
            </div>
            <p>${content}</p>
          `;
          card.onpointerdown = (event) => startSurfaceDrag(event, surface.id);
          card.onkeydown = (event) => {
            if (event.key !== 'Enter' && event.key !== ' ') return;
            event.preventDefault();
            if (surface.app_id) {
              focusApp(surface.app_id, true);
            }
          };
          card.onfocus = () => {
            if (surface.app_id && surface.app_id !== currentFocusedApp) {
              focusApp(surface.app_id, true);
            }
          };
          surfacesEl.appendChild(card);
          surfaceElements.set(surface.id, card);

          const { x, y, w, h } = getSurfaceBounds(surface);
          maxBottom = Math.max(maxBottom, y + h + 90);
          maxRight = Math.max(maxRight, x + w + 90);
        }

        const stageWidth = stageEl ? stageEl.clientWidth : maxRight;
        surfacesEl.style.minHeight = `${maxBottom}px`;
        surfacesEl.style.minWidth = `${Math.max(stageWidth, maxRight)}px`;
      }

      function setPendingApproval(payload) {
        pendingApproval = payload;
        if (!payload) {
          approvalTitleEl.textContent = 'No pending approval';
          approvalRiskEl.innerHTML = '';
          approveBtn.disabled = true;
          rejectBtn.disabled = true;
          return;
        }
        approvalTitleEl.textContent = payload.title;
        approvalRiskEl.innerHTML = `<span class="risk-badge risk-${payload.risk}">${payload.risk}</span>`;
        approveBtn.disabled = false;
        rejectBtn.disabled = false;
      }

      async function loadApps() {
        const res = await fetch('/api/os/apps');
        const body = await res.json();
        for (const app of body.apps || []) {
          appCatalog.set(app.id, app);
        }
      }

      async function createSession() {
        const res = await fetch('/api/os/session', { method: 'POST' });
        const body = await res.json();
        sessionId = body.session_id;
        sessionEl.textContent = sessionId.slice(0, 8);
      }

      function connectStream() {
        if (stream) stream.close();
        stream = new EventSource(`/api/os/stream/${sessionId}`);
        setStatus('streaming');

        const allEvents = [
          'shell_state', 'app_surface_ops', 'timeline_entry', 'approval_required',
          'notification', 'error', 'done', 'ping'
        ];

        for (const name of allEvents) {
          stream.addEventListener(name, (evt) => {
            const envelope = JSON.parse(evt.data);
            const payload = envelope.payload;
            log(`sse.${name}`, payload);

            if (payload.kind === 'shell_state') {
              const data = payload.data;
              currentActiveApps = data.active_apps || [];
              currentFocusedApp = data.focused_app || null;
              renderDock(currentActiveApps, data.focused_app || null);
              focusedEl.textContent = `focused: ${data.focused_app || 'none'}`;
              renderSurfaces();
            }

            if (payload.kind === 'app_surface_ops') {
              for (const op of payload.data.ops || []) {
                if (op.op === 'create') surfaces.set(op.id, op);
                if (op.op === 'patch' && surfaces.has(op.id)) {
                  const existing = surfaces.get(op.id);
                  existing.props = { ...(existing.props || {}), ...(op.props || {}) };
                }
                if (op.op === 'remove') surfaces.delete(op.id);
              }
              renderSurfaces();
            }

            if (payload.kind === 'timeline_entry') {
              pushTimeline(payload.data.level, payload.data.message);
            }

            if (payload.kind === 'approval_required') {
              setPendingApproval(payload.data);
              pushTimeline('warn', `Approval required for ${payload.data.app_id}`);
            }

            if (payload.kind === 'notification') {
              pushTimeline(payload.data.level, payload.data.message);
            }

            if (payload.kind === 'done') {
              setStatus('done');
            }
            if (payload.kind === 'error') {
              setStatus('error');
            }
          });
        }

        stream.onerror = () => {
          setStatus('disconnected');
        };
      }

      async function runPrompt(prompt) {
        setStatus('running');
        const res = await fetch(`/api/os/prompt/${sessionId}`, {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ prompt }),
        });
        const body = await res.json();
        log('prompt.response', body);
      }

      async function sendEvent(event) {
        log('event.outbound', event);
        const res = await fetch(`/api/os/event/${sessionId}`, {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ seq: Date.now(), event }),
        });
        const body = await res.json();
        log('event.ack', body);
      }

      runBtn.onclick = () => runPrompt(promptEl.value);
      approveBtn.onclick = async () => {
        if (!pendingApproval) return;
        await sendEvent({
          type: 'approval_decision',
          action_id: pendingApproval.action_id,
          approved: true,
        });
        setPendingApproval(null);
      };

      let currentFocusedApp = null;
      let dragState = null;
      const dockButtons = () => Array.from(dockEl.querySelectorAll('.dock-btn'));

      function syncSurfaceFocusClasses() {
        surfaceElements.forEach((element, surfaceId) => {
          const surface = surfaces.get(surfaceId);
          const isFocused = Boolean(surface && surface.app_id && surface.app_id === currentFocusedApp);
          element.classList.toggle('active', isFocused);
        });
      }

      function focusApp(appId, emit = true) {
        if (!appId) return;
        currentFocusedApp = appId;
        focusedEl.textContent = `focused: ${appId}`;
        renderDock(currentActiveApps, currentFocusedApp);
        syncSurfaceFocusClasses();
        if (emit) {
          sendEvent({ type: 'app_focus', app_id: appId });
        }
      }

      function focusPromptInput() {
        promptEl.focus();
        promptEl.select();
      }

      function cycleFocusedApp(direction) {
        if (!currentActiveApps.length) return;
        const currentIndex = currentActiveApps.indexOf(currentFocusedApp || '');
        const base = currentIndex >= 0 ? currentIndex : 0;
        const nextIndex = (base + direction + currentActiveApps.length) % currentActiveApps.length;
        focusApp(currentActiveApps[nextIndex], true);
      }

      function isEditableTarget(target) {
        if (!(target instanceof HTMLElement)) return false;
        const tag = target.tagName.toLowerCase();
        return tag === 'input' || tag === 'textarea' || target.isContentEditable;
      }

      function bringSurfaceToFront(surfaceId) {
        const surface = surfaces.get(surfaceId);
        if (!surface) return false;
        let maxZ = 0;
        surfaces.forEach((candidate) => {
          maxZ = Math.max(maxZ, getSurfaceBounds(candidate).z);
        });
        const { z } = getSurfaceBounds(surface);
        const nextZ = maxZ + 1;
        if (nextZ === z) return false;

        surface.props = {
          ...(surface.props || {}),
          z_index: nextZ,
        };
        const element = surfaceElements.get(surfaceId);
        if (element) {
          applySurfaceStyles(element, surface);
        }
        return true;
      }

      function emitWorkspaceLayoutChange() {
        const layout = JSON.stringify(serializeSurfaceLayout());
        sendEvent({ type: 'workspace_layout_change', layout });
      }

      function startSurfaceDrag(event, surfaceId) {
        if (event.button !== 0) return;
        const surface = surfaces.get(surfaceId);
        const card = surfaceElements.get(surfaceId);
        if (!surface || !card) return;

        event.preventDefault();

        const { x, y } = getSurfaceBounds(surface);
        const zChanged = bringSurfaceToFront(surfaceId);
        if (surface.app_id) {
          focusApp(surface.app_id, true);
        }

        dragState = {
          surfaceId,
          pointerId: event.pointerId,
          startX: event.clientX,
          startY: event.clientY,
          originX: x,
          originY: y,
          moved: false,
          layoutDirty: zChanged,
        };

        if (card.setPointerCapture) {
          card.setPointerCapture(event.pointerId);
        }
        card.classList.add('dragging');
      }

      function onSurfacePointerMove(event) {
        if (!dragState || dragState.pointerId !== event.pointerId) return;
        const surface = surfaces.get(dragState.surfaceId);
        const card = surfaceElements.get(dragState.surfaceId);
        if (!surface || !card) return;

        const dx = event.clientX - dragState.startX;
        const dy = event.clientY - dragState.startY;
        if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
          dragState.moved = true;
        }

        const next = constrainSurfacePosition(
          surface,
          dragState.originX + dx,
          dragState.originY + dy,
          false,
        );
        surface.props = {
          ...(surface.props || {}),
          x: next.x,
          y: next.y,
        };
        applySurfaceStyles(card, surface, 8);
        dragState.layoutDirty = true;
      }

      function finishSurfaceDrag(event) {
        if (!dragState || dragState.pointerId !== event.pointerId) return;
        const state = dragState;
        dragState = null;

        const surface = surfaces.get(state.surfaceId);
        const card = surfaceElements.get(state.surfaceId);
        if (surface && card) {
          const current = getSurfaceBounds(surface);
          const snapped = constrainSurfacePosition(surface, current.x, current.y, true);
          card.classList.remove('dragging');
          surface.props = {
            ...(surface.props || {}),
            x: snapped.x,
            y: snapped.y,
          };
          if (snapped.x !== current.x || snapped.y !== current.y) {
            state.layoutDirty = true;
          }
          applySurfaceStyles(card, surface);
          if (card.releasePointerCapture && card.hasPointerCapture(state.pointerId)) {
            card.releasePointerCapture(state.pointerId);
          }
        }
        if (state.layoutDirty) {
          emitWorkspaceLayoutChange();
        }
      }

      function resetDockDepth() {
        dockButtons().forEach((btn, index) => {
          btn.style.setProperty('--dock-depth', `${index * 1.6}px`);
          btn.style.setProperty('--dock-tilt-x', '0deg');
          btn.style.setProperty('--dock-tilt-y', '0deg');
        });
      }

      function resetSidebarDepth() {
        sidebarPanels.forEach((panel, index) => {
          const depth = sidebarDepths[index] || 0;
          const offset = sidebarOffsets[index] || 0;
          panel.style.setProperty('--depth', `${depth}px`);
          panel.style.setProperty('--offset', `${offset}px`);
          panel.style.setProperty('--tilt-x', '0deg');
          panel.style.setProperty('--tilt-y', `${sidebarYawBase[index] || 0}deg`);
          panel.style.setProperty('--mx', '50%');
          panel.style.setProperty('--my', '14%');
          panel.style.animationDelay = `${index * -1.3}s`;
        });
      }

      if (workspaceEl) {
        workspaceEl.addEventListener('pointermove', (event) => {
          if (!stageEl || window.innerWidth <= 1200) return;
          const bounds = stageEl.getBoundingClientRect();
          const px = ((event.clientX - bounds.left) / bounds.width) - 0.5;
          const py = ((event.clientY - bounds.top) / bounds.height) - 0.5;
          surfacesEl.style.transform = `rotateX(${(-py * 2.4).toFixed(2)}deg) rotateY(${(px * 3.2).toFixed(2)}deg)`;
        });
        workspaceEl.addEventListener('pointerleave', () => {
          surfacesEl.style.transform = 'rotateX(0deg) rotateY(0deg)';
        });
      }
      window.addEventListener('pointermove', onSurfacePointerMove);
      window.addEventListener('pointerup', finishSurfaceDrag);
      window.addEventListener('pointercancel', finishSurfaceDrag);

      if (sidebarEl) {
        resetSidebarDepth();
        sidebarEl.addEventListener('pointermove', (event) => {
          if (window.innerWidth <= 1200) return;
          const bounds = sidebarEl.getBoundingClientRect();
          const px = ((event.clientX - bounds.left) / bounds.width) - 0.5;
          const py = ((event.clientY - bounds.top) / bounds.height) - 0.5;
          sidebarPanels.forEach((panel, index) => {
            const rect = panel.getBoundingClientRect();
            const localX = clamp(((event.clientX - rect.left) / rect.width) * 100, 0, 100);
            const localY = clamp(((event.clientY - rect.top) / rect.height) * 100, 0, 100);
            const depth = sidebarDepths[index] || 0;
            const offset = sidebarOffsets[index] || 0;
            const yaw = (sidebarYawBase[index] || 0) + px * (1.6 + (index * 0.3));
            const pitch = -py * (1.2 + (index * 0.2));
            const hoverLift = 1 + (index * 0.3);
            panel.style.setProperty('--depth', `${depth + hoverLift}px`);
            panel.style.setProperty('--offset', `${offset}px`);
            panel.style.setProperty('--tilt-x', `${pitch.toFixed(2)}deg`);
            panel.style.setProperty('--tilt-y', `${yaw.toFixed(2)}deg`);
            panel.style.setProperty('--mx', `${localX.toFixed(2)}%`);
            panel.style.setProperty('--my', `${localY.toFixed(2)}%`);
          });
        });
        sidebarEl.addEventListener('pointerleave', () => {
          resetSidebarDepth();
        });
      }
      if (dockEl) {
        dockEl.addEventListener('pointermove', (event) => {
          if (window.innerWidth <= 1200) return;
          const rail = dockEl.getBoundingClientRect();
          const railPx = ((event.clientX - rail.left) / rail.width) - 0.5;
          const railPy = ((event.clientY - rail.top) / rail.height) - 0.5;
          dockButtons().forEach((btn, index) => {
            const rect = btn.getBoundingClientRect();
            const cx = rect.left + (rect.width / 2);
            const cy = rect.top + (rect.height / 2);
            const distance = Math.hypot(event.clientX - cx, event.clientY - cy);
            const influence = clamp(1 - (distance / 180), 0, 1);
            const depth = (index * 1.6) + (influence * 14);
            const tiltX = (-railPy * 3.6 * influence).toFixed(2);
            const tiltY = (railPx * 4.4 * influence).toFixed(2);
            btn.style.setProperty('--dock-depth', `${depth.toFixed(2)}px`);
            btn.style.setProperty('--dock-tilt-x', `${tiltX}deg`);
            btn.style.setProperty('--dock-tilt-y', `${tiltY}deg`);
          });
        });
        dockEl.addEventListener('pointerleave', () => {
          resetDockDepth();
        });
      }
      window.addEventListener('keydown', (event) => {
        const withMeta = event.metaKey || event.ctrlKey;
        if (!withMeta) return;

        if (event.key.toLowerCase() === 'k') {
          event.preventDefault();
          focusPromptInput();
          return;
        }

        if (isEditableTarget(event.target)) {
          return;
        }

        if (event.key === ']') {
          event.preventDefault();
          cycleFocusedApp(1);
          return;
        }

        if (event.key === '[') {
          event.preventDefault();
          cycleFocusedApp(-1);
        }
      });
      rejectBtn.onclick = async () => {
        if (!pendingApproval) return;
        await sendEvent({
          type: 'approval_decision',
          action_id: pendingApproval.action_id,
          approved: false,
        });
        setPendingApproval(null);
      };

      (async () => {
        try {
          await loadApps();
          await createSession();
          connectStream();
          pushTimeline('info', 'Shell ready. Submit a Master Prompt.');
        } catch (error) {
          setStatus('error');
          log('boot.error', { message: String(error) });
        }
      })();
    </script>
  </body>
</html>
